# 总览

总体来说 就是低精度 可以向 高精度转换 
![](..\Image\0051_01_类型的自动转换.png)
![](../Image/0039_01_数据类型总览.png)

```sql
- int a= 'c' // 这个是可以
- double d = 80 // 这个是可以的
```

# 注意事项和细节

1. 多种数据类型混合运算时，系统首先自动将所有数据类型转换为容量最大的那种数据类型，再计算。
   
   1. float d1 = n1 + 1,1 // 错误 因为 1.1 自动默认为 double 类型

2. 容量大的数据类型赋值给容量小的会报错（精度丢失），小赋值给大的可以（自动类型转换）。
   
   1. int n2 = 1.1 //错误 因为 1.1 为浮点数 > int的精度 
   
   2. 当把 数字 赋给 byte 的时候 (int 范围为 4 byte, byte 范围为 1 byte)， 先判断这个数 是否在 byte 范围内 （8bit， -127 bis 127  ） 。 如果可以 ， 那这样的复制就没有问题。 只输入一个数字的话 ， 不会自动把这个数字 弄成 int 类型
      
      1. byte b1  = 10 // 不报错
      2. byte b2  = 99999999999 // 会报错 
   
   3. 当把 直接把 一个变量  （比如为 int） 赋给 byte 的时候 (int 范围为 4 byte, byte 范围为 1 byte)， 那就不管这套了
      
      1. int n2 = 1; byte b2 = n2 ；// 会报错， 因为 n2 已经  为 int, 已经有一个 4 byte 空间 ， 不再能 塞到 1 byte 空间中了 

3. (byte，short）和char之间不会相互自动转换

4. byte，short，char之间可以计算，计算时首先转换为int. (这是编译器之前事先 就规定好的 )
   
   1. byte b2  = 1; short s1 = 1; short s2 = b2 + s1; // 會報錯 ， 因为 b2+ s1 的时候， 已经 自动把精度提到 int 了。 而且 int 的精度 > short
   2. byte b2  = 1; byte  s1 = 1; byte s2 = b2 + s1; // 會報錯 ， 因为 b2+ s1 的时候， 已经 自动把精度提到 int 了, 虽然 b2 和 s1 都是 byte 类型的 

5. boolean不参与转换

6. 自动提升原则： 表达式结果中的类型自动提升为 精度最大的类型。
   
   1. ```java
      byte b4 = 1;
      short s3 = 100;
      int num200 = 1;
      double num3003 =1 
      
      s1 = b4+ s3 + num200 + num3003 , 出来的 数据类型为 double
      ```
      
      ```
      
      ```
