
# 1 对象处理流理论

- Object 流的优点:  既可以保存数据的类型, 也可以保存数据的值.

## 1.1 序列化 反序列化

- 保存值的同时保存数据类型（**序列化**） 如保存int 100；在恢复数据时，恢复数据的值和数据类型（**反序列化**）；
- 实现Serializable（标记接口，没有方法），或Externalizable的类才可以序列化

![](image/Pasted%20image%2020230423125340.png)


![](https://img-blog.csdnimg.cn/e6f0efc07b0448708eb064cc576ac672.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aWI5pav5p2O5YWI55Sf,size_20,color_FFFFFF,t_70,g_se,x_16)

- 必须在定义的时候 加上 implements Serializable, 或者 implements Externalizable, 如果不加上的话, 就支持 序列化机制 
	- 比如 Class Dog  implements Serializable{}
 -优先使用Serializable接口，因为这个接口没有方法。
 -Externalziable 也是继承了 java.io.Serializable, 内含两个方法
 
![](image/Pasted%20image%2020230423130158.png)

![](image/Pasted%20image%2020230423130209.png)

## 1.2 对象处理流的使用细节  
![](https://img2020.cnblogs.com/blog/2279140/202108/2279140-20210827101814067-590172517.png)


### 1.2.1 SerialVersion UID 为序列化的版本号
	-  例子 加上 一个 新的 attribute Private Srting hobby, 如果此有 private static final long seriaVersionUID = 1L;  则会将 将加上 一个 新的attribute 的郑重 修改视为版本更新而不是一个新的类，提高兼容性
![](image/Pasted%20image%2020230423134106.png)

### 1.2.2 static 或者 transient 修饰的成员 不会被序列化,
就是说 这种类型的成员 不会被 保存, 不会被 序列化 , 反序列的话的时候不会被保存不会被显示 

![](image/Pasted%20image%2020230423134517.png)

![](image/Pasted%20image%2020230423134400.png)

### 1.2.3 序列化对象时候, 要求 这个对象里面的所有的属性的类型 都要已经实现了序列化接口.  不然会报错

![](image/Pasted%20image%2020230423135631.png)

![](image/Pasted%20image%2020230423135643.png)

![](image/Pasted%20image%2020230423135650.png)

### 1.2.4 序列化具有继承性

![](image/Pasted%20image%2020230423135747.png)

### 1.2.5 反序列化；
-   反序列化顺序要和序列化顺序一致
-   反序列化时，类需要在ObjectInputStream中定义
-   要使用反序列化类的方法，需要向下转型，并将类的定义拷贝到可以引用的位置

# 2 ObjectOutputStream And ObjectInputStream
功能：提供了对基本类型或对象类型的序列化和反序列化的方法；
②  ObjectOutputStream 提供 序列化功能；
③   ObjectInputStream 提供 反序列化功能。

![](image/Pasted%20image%2020230423130328.png)

## 2.1 ObjectOutputStream  序列化

用ObjectOutputStream序列化一个Dog对象，保存到data.dat文件中（序列化后，保存的文件格式不是纯文本的，而是默认的）；
包装类Integer实现了Serializable；

```JAVA
package com.hspedu.outputstream_;
韩顺平循序渐进学Java 零基础
第852页
import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
/**
 * @author 韩顺平
 * @version 1.0
 * 演示ObjectOutputStream 的使用, 完成数据的序列化
 */
public class ObjectOutStream_ {
    public static void main(String[] args) throws Exception {
        //序列化后，保存的文件格式，不是存文本，而是按照他的格式来保存
        String filePath = "e:\\data.dat";
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filePath));
        
        //序列化数据到e:\data.dat
        oos.writeInt(100); // int -> Integer (实现了Serializable)
        oos.writeBoolean(true); // boolean -> Boolean (实现了Serializable)
        oos.writeChar('a'); // char -> Character (实现了Serializable)
        oos.writeDouble(9.5); // double -> Double (实现了Serializable)
        oos.writeUTF("韩顺平教育"); //String 这个class也已经实现了 implements Serializable 了
        //保存一个dog 对象
        oos.writeObject(new Dog("旺财", 10, "日本", "白色"));
        oos.close();
        System.out.println("数据保存完毕(序列化形式)");
    }
}
```

![](image/Pasted%20image%2020230423131427.png)

![](image/Pasted%20image%2020230423131204.png)

## 2.2 ObjectInputStream 反序列化；
-   反序列化顺序要和序列化顺序一致
-   反序列化时，类需要在ObjectInputStream中定义
-   要使用反序列化类的方法，需要向下转型，并将类的定义拷贝到可以引用的位置


例子: 读取data.dat文件中 内容 并反序列化恢复数据

```java
package com.hspedu.inputstream_;



import com.hspedu.outputstream_.Dog;

import java.io.*;

/**
 * @author 韩顺平
 * @version 1.0
 */
public class ObjectInputStream_ {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        //指定反序列化的文件
        String filePath = "e:\\data.dat";
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filePath));
        
        //读取
        //老师解读
        //1. 读取(反序列化)的顺序需要和你保存数据(序列化)的顺序一致
        //2. 否则会出现异常
        System.out.println(ois.readInt());
        System.out.println(ois.readBoolean());
        System.out.println(ois.readChar());
        System.out.println(ois.readDouble());
        System.out.println(ois.readUTF());

        //dog 的编译类型是 Object , dog 的运行类型是 Dog
        Object dog = ois.readObject();
        System.out.println("运行类型=" + dog.getClass());
        System.out.println("dog信息=" + dog);//底层 Object -> Dog

        //这里是特别重要的细节:

        //1. 如果我们希望调用Dog的方法, 需要向下转型
        //2. 需要我们将Dog类的定义，放在到可以引用的位置 (1 通过 包引用 而且要到同一个包下 , 2 或者通过 将 Dog class 放在同一个 java w文件下, 3 或者将 dog class 公有化 就是 定义为 public class Dog implements Serializable {}. 因为 class的修饰符默认的时候 (非public) 只能在同一个包或者同类下 才能条用这个 class  )
        Dog dog2 = (Dog)dog;
        System.out.println(dog2.getName()); //旺财..

        //关闭流, 关闭外层流即可，底层会关闭 FileInputStream 流
        ois.close();
    }
}


```

输出值
![](image/Pasted%20image%2020230423132244.png)


2 重写Dog class 的 toString()
![](image/Pasted%20image%2020230423132329.png)

![](image/Pasted%20image%2020230423132343.png)

3 引入  dog class 所在的 包
![](image/Pasted%20image%2020230423133319.png)

3 将 dog class 公有化 就是 定义为 public class Dog implements Serializable {})
因为 class的修饰符默认的时候 (非public) 只能在同一个包或者同类下 才能条用这个 class 
![](image/Pasted%20image%2020230423133309.png)