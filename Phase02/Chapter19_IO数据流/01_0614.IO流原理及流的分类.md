Streams:
Byte streams, character streams
Buffered streams
Sequences of streams

# 1 #

![](image/Pasted%20image%2020230419153800.png)

# 2 åŸºæœ¬æ¦‚å¿µ


A stream may represent different resources â€“files on disk, network resources, other programs, other streams, etc.

Streams may just pass on data or manipulate it, but all streams use the same programming model where data is read from or written to a stream sequentially. => A stream is a sequence of data items.

![[Pasted image 20250416163015.png]]


Datenquelle: Eine Datenquelle (data source) ist ein Objekt, von dem Daten eingelesen werden kÃ¶nnen.
Datensenke: Eine Datensenke (data sink) ist ein Objekt, in das die Daten ausgegeben werden kÃ¶nnen.
Die kleinste Einheit in einem Datenstrom ist ein Byte. Ist die zu transportierende Datenmenge grÃ¶ÃŸer als ein Byte, gelangen die Daten als Bytefolge in den Datenstrom
Die Verbindung zwischen Datenquelle und Programm wird als Eingabestrom bezeichnet, die Verbindung zwischen Programm und Datensenke als Ausgabestrom. 


# 3 IOæµåŸç†
java.io è¿™ä¸ª package

ï¼ˆ1ï¼‰I/Oæ˜¯Input/Outputçš„ç¼©å†™ï¼ŒI/OæŠ€æœ¯æ˜¯éå¸¸å®ç”¨çš„æŠ€æœ¯ï¼Œç”¨äºå¤„ç†æ•°æ®ä¼ è¾“ã€‚å¦‚è¯»/å†™æ–‡ä»¶ï¼Œç½‘ç»œé€šè®¯ç­‰ï¼›
ï¼ˆ2ï¼‰Javaç¨‹åºä¸­ï¼Œå¯¹äºæ•°æ®çš„è¾“å…¥/è¾“å‡ºæ“ä½œä»¥â€œæµï¼ˆstreamï¼‰â€çš„æ–¹å¼è¿›è¡Œï¼›
ï¼ˆ3ï¼‰java.ioåŒ…ä¸‹æä¾›äº†å„ç§â€œæµâ€ç±»å’Œæ¥å£ï¼Œç”¨ä»¥è·å–ä¸åŒç§ç±»çš„æ•°æ®ï¼Œå¹¶é€šè¿‡æ–¹æ³•è¾“å…¥æˆ–è¾“å‡ºæ•°æ®ï¼›
ï¼ˆ4ï¼‰è¾“å…¥inputï¼šè¯»å–å¤–éƒ¨æ•°æ®ï¼ˆç£ç›˜ï¼Œå…‰ç›˜ç­‰å­˜å‚¨è®¾å¤‡çš„æ•°æ®ï¼‰åˆ°ç¨‹åºï¼ˆå†…å­˜ï¼‰ä¸­ï¼›
ï¼ˆ5ï¼‰è¾“å‡ºoutputï¼šå°†ç¨‹åºï¼ˆå†…å­˜ï¼‰æ•°æ®è¾“å‡ºåˆ°ç£ç›˜ï¼Œå…‰ç›˜ç­‰å­˜å‚¨è®¾å¤‡ä¸­ã€‚


![](image/Pasted%20image%2020230419173032.png)




# 4 æµçš„åˆ†ç±»


ä¸€ä¸ªå­—ç¬¦å ä½å‡ ä¸ªå­—èŠ‚, è¦çœ‹å“ªä¸ªç¼–ç æ ¼å¼ 

![](image/Pasted%20image%2020230419173308.png)


- Byteorientierte StrÃ¶me
	- Diese transportieren Bytes, die in binÃ¤rer Form in Dateien gespeichert bzw. ausgegeben werden.
- Zeichenorientierte StrÃ¶me**  
	- Diese transportieren Zeichen, die in einer von Menschen lesbaren Form ein- oder ausgegeben werden.
- ObjektstrÃ¶me
	- ObjektstrÃ¶me ermÃ¶glichen es Objekte als Ganzes mit ihren aktuellen Daten Ã¼ber eine einzige Anweisung (readObject bzw. writeObject) aus einer Datenquelle einzulesen oder in einer Datensenke auszugeben. Die Struktur des gelesenen oder geschriebenen Objektes kann beliebig komplex sein und Referenzen zu anderen verbunden Objekte enthalten, wie zum Beispiel ein Array
- Pufferklasse
	- (buffer classes) werden verwendet um Daten aus EingabestrÃ¶men (BufferedReader) oder AusgabestrÃ¶men (BufferedWriter) zwischenzuspeichern.|


# 5 IOæµä½“ç³»å›¾-å¸¸ç”¨çš„ç±»

![](https://img-blog.csdnimg.cn/71e05d0284df419181f1c27a5d4d540b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aWI5pav5p2O5YWI55Sf,size_19,color_FFFFFF,t_70,g_se,x_16)

https://zhuanlan.zhihu.com/p/88233122
![](image/Pasted%20image%2020230420145526.png)

![](image/Pasted%20image%2020230420213618.png)

- èŠ‚ç‚¹æµnode , å¤„ç†æµ/åŒ…è£…æµ package 
- è¾“å…¥æµ. è¾“å‡ºæµ
- å­—èŠ‚æµbyte, å­—ç¬¦æµchar
- æ–‡ä»¶æµFile , ç¼“å†²æµBuffer, æ•°æ®æµdata (Binary primitiven Datentypen),  å¯¹è±¡æµObject (Serialisierbaren Objekten als Byte Folge)


# 6 Filter class 
Filterklassen sind Klassen, die aus einem bereits existierenden Datenstrom erzeugt werden und dessen Daten filtern.

Filterklassen sind Klassen, bei denen neue DatenstrÃ¶me aus vorhandenen erzeugt werden, indem die einzelnen Elemente der DatenstrÃ¶me beliebig verarbeitet werden. 

# 7 ä¸åŒçš„ stream 

## 7.1 byte streams and character streams.

There are two kinds of streams: byte streams and character streams.
- Byte streams use 8 bit blocks, i.e., they read and write bytes. This is useful for binary data.
- Character streams use 16 bit blocks, i.e., they read and write two bytes = one character. They also translate internal unicode-based character encoding to external encodings. Character streams are useful for text-based data.

- All byte streams are subclasses of the abstract classes InputStreamor OutputStream.
- All character streams are child classes of the abstract classes Readeror Writer.


Examples of streams â€“byte streams
FileInputStream and FileOutputStreamare used to access files.

```java
FileInputStreamin = null;
FileOutputStreamout = null;
try { in = new FileInputStream("myfile.dat");
    out = new FileOutputStream("myotherfile.dat");
    int c;
    while ((c = in .read()) != -1) out.write(c);
} catch (IOExceptione) {
    e.printStackTrace();
} finally {
    if ( in != null) in .close();
    if (out != null) out.close();
}
```


Examples of streams â€“character streams
FileReaderand FileWriterare also used to access files.
```java
FileReaderin = null;
FileWriterout = null;
try { in = new FileReader("myfile.txt");
    out = new FileWriter("myotherfile.txt");
    int c;
    while ((c = in .read()) != -1) out.write(c);
} catch (IOExceptione) {
    e.printStackTrace();
} finally {
    if ( in != null) in .close();
    if (out != null) out.close();
}
```

## 7.2 FileInputStream vs. FileReader

Both streams return an intvalue through their read()method

![[Pasted image 20250416163541.png]]


## 7.3 Bridging character and byte streams è½¬æ¢æµ: InputStreamReader and OutputStreamWriter

è½¬æ¢æµ *InputStreamReader OutputStreamWriter*- è¦inputStream æˆ–OutputStreamä½œä¸ºå‚æ•°ï¼Œå®ç°ä»å­—èŠ‚æµåˆ°å­—ç¬¦æµçš„è½¬æ¢

InputStreamReader and OutputStreamWriter enable us to bridge between character and byte streams.

InputStreamReader is a character stream but takes an instance of InputStream as constructor parameter, i.e., it translates the byte stream into a character stream.

OutputStreamWriter is a character stream that takes an instance of OutputStream as constructor parameter, i.e., it takes characters as input and writes them into the specified OutputStreaminstance: each character as two bytes.


## 7.4 Buffered streams

Beyond BufferedReader, there are also BufferedWriter, BufferedInputStream, and BufferedOutputStreamwhich add buffering to their respective stream class.

![[Pasted image 20250416203830.png]]


The buffers of buffered streams are only emptied when we:
explicitly invoke the flush()method,
close the stream, or completely fill the buffer.


### 7.4.1 BufferedReader

Character streams rarely read single characters but are typically based on lines (e.g., separated by â€œ\nâ€œ). Instances of BufferedReaderallow us to read entire lines instead of single characters.

This also increases efficiency.
Character streams rarely read single characters but are typically based on lines (e.g., separated by â€œ\nâ€œ). Instances of BufferedReaderallow us to read entire lines instead of single characters.

```
BufferedReaderbr= newBufferedReader(newFileReader("src.txt"));
String line= null;
while((line= br.readLine())!=null){
	System.out.println(line);
}
br.close();
```


## 7.5 PrintWriter


PrintWriteradds formatted output to our character stream.

In fact: System.out.println();
=> outis a class variable in class System. Its type is PrintStreamwhich behaves exactly like instances of PrintWriter*.

```
BufferedReaderbr = new BufferedReader(new FileReader("src.txt"));
PrintWriterout = new PrintWriter(new FileWriter("copy.txt"));
String line = null;
while ((line = br.readLine()) != null) {
    out.println(line);
}
br.close();
out.close();
```


## 7.6 Object serialization

- Instances of ObjectInputStream provide a method readObject()but also methods like readInt(), or readDouble().
	- - ç”¨äº**å°†å¯¹è±¡å†™å…¥ï¼ˆåºåˆ—åŒ–ï¼‰åˆ°æ–‡ä»¶ã€å†…å­˜æˆ–ç½‘ç»œä¸­**ã€‚
- Instances of ObjectOutputStream provide the opposite methods, e.g., writeObject(), writeInt(), writeDouble().
	- ç”¨äº**ä»æ–‡ä»¶ã€å†…å­˜æˆ–ç½‘ç»œä¸­è¯»å–å¯¹è±¡ï¼ˆååºåˆ—åŒ–ï¼‰**ã€‚
	- `readObject()`ï¼šè¯»å–ä¸€ä¸ªå¯¹è±¡ï¼ˆè¿”å›ç±»å‹æ˜¯ `Object`ï¼Œéœ€è¦å¼ºåˆ¶ç±»å‹è½¬æ¢ï¼‰ã€‚
- Instead of working with instances of Object, though, readObject() and writeObject() work with objects that are instances of Serializable.

==Serializableis a so-called marker interface, i.e., it has no methods but forces the developer to think about serialization by explicitly implementing said interface.==

---

Serializable æ˜¯ä»€ä¹ˆï¼Ÿ
- `Serializable` æ˜¯ä¸€ä¸ª**æ ‡è®°æ¥å£ï¼ˆmarker interfaceï¼‰**ã€‚
- **å®ƒæ²¡æœ‰ä»»ä½•æ–¹æ³•**ï¼Œä¹Ÿå°±æ˜¯è¯´ä½ ä¸éœ€è¦é‡å†™ä»»ä½•æ–¹æ³•ã€‚
- **ä½œç”¨æ˜¯å‘Šè¯‰ Javaï¼šè¿™ä¸ªç±»çš„å¯¹è±¡å¯ä»¥è¢«åºåˆ—åŒ–ã€‚**

```java
import java.io.Serializable;

public class User implements Serializable {
    private String name;
    private int age;
}
```

ä¸ºä»€ä¹ˆç§°ä¹‹ä¸ºâ€œmarker interfaceï¼ˆæ ‡è®°æ¥å£ï¼‰â€ï¼Ÿ
- å› ä¸ºå®ƒå°±åƒä¸€ä¸ªæ ‡ç­¾/æ ‡å¿—ï¼Œ**ä¸åŒ…å«æ–¹æ³•ï¼Œåªæ˜¯ä½œä¸ºâ€œæç¤ºâ€ç»™ Java çš„åºåˆ—åŒ–æœºåˆ¶**ï¼š
    > â€œè¿™ä¸ªç±»çš„å¯¹è±¡æ˜¯å¯ä»¥å®‰å…¨åœ°å†™å…¥æ–‡ä»¶æˆ–ç½‘ç»œä¸­å¹¶ç¨åæ¢å¤å‡ºæ¥çš„ã€‚â€

---



â€œè¿™ä¸ªç±»çš„å¯¹è±¡å¯ä»¥è¢«åºåˆ—åŒ–â€çš„æ„æ€æ˜¯ï¼š
ğŸ‘‰ **ä½ å¯ä»¥æŠŠè¿™ä¸ªå¯¹è±¡è½¬æ¢æˆä¸€ä¸²å­—èŠ‚ï¼ˆbyte streamï¼‰æ¥ä¿å­˜æˆ–ä¼ è¾“**ï¼Œæ¯”å¦‚ï¼š
- ä¿å­˜åˆ°ç¡¬ç›˜ä¸Šçš„ `.ser` æ–‡ä»¶
- é€šè¿‡ç½‘ç»œå‘é€åˆ°åˆ«çš„ç³»ç»Ÿ
- å­˜å…¥ç¼“å­˜æˆ–æ•°æ®
å¹¶ä¸”ï¼š ğŸ‘‰ **ä¹‹åä½ å¯ä»¥æŠŠè¿™ä¸²å­—èŠ‚å†è¿˜åŸï¼ˆååºåˆ—åŒ–ï¼‰æˆåŸæ¥çš„å¯¹è±¡**


å¥½å¤„ï¼š
- **è·¨å¹³å°**ï¼šä½ å¯ä»¥æŠŠå¯¹è±¡ä»ä¸€ä¸ªç¨‹åºå†™å‡ºæ¥ï¼Œåœ¨å¦ä¸€ä¸ªç¨‹åºä¸­è¿˜åŸã€‚
- **æŒä¹…åŒ–**ï¼šä½ å¯ä»¥æŠŠå¯¹è±¡ä¿å­˜æˆæ–‡ä»¶ï¼Œä»¥åå†æ¢å¤ä½¿ç”¨ã€‚    
- **è¿œç¨‹é€šä¿¡**ï¼šç½‘ç»œä¼ è¾“ Java å¯¹è±¡ï¼ˆæ¯”å¦‚ RMIï¼‰æ—¶è¦ç”¨åºåˆ—åŒ–ã€‚


```
import java.io.Serializable;

public class Person implements Serializable {
    String name;
    int age;
}
```

æŠŠ `new Person("Tom", 25)` ä¿å­˜åˆ°æ–‡ä»¶ä¸­ï¼š
```
ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("person.ser"));
oos.writeObject(person);
```

ç¨åä½ å¯ä»¥ä»æ–‡ä»¶ä¸­è¯»å›è¿™ä¸ªå¯¹è±¡ï¼š
```
ObjectInputStream ois = new ObjectInputStream(new FileInputStream("person.ser"));
Person p = (Person) ois.readObject();
```


# 8 Closing streams

â€¢Streams always need to be closed in the end, it is, therefore, good practice to have a mystream.close()call in the finallyblock.
â€¢Since the close()method may also throw an exception this always leads to code like this:

```java
FileOutputStreamout = null;
try {
    out = new FileOutputStream("myfile.dat");
    out.write(123);
} catch (IOExceptione) {
    e.printStackTrace();
} finally {
    try {
        if (out != null) out.close();
    } catch (IOExeptionioe) {
        /*do nothing*/
    }
}
```

--- 

## 8.1 AutoClosable

Java 7 introduced the try-with-resources block to circumvent this nuisance (which is especially useful, since close() calls will rarely throw exceptions).
This variant of the try block works with all resources (here: streams) that implement the interface AutoClosable.
è¿™æ®µè®²çš„æ˜¯ Java 7 å¼•å…¥çš„ä¸€ä¸ªéå¸¸å®ç”¨çš„è¯­æ³•ç‰¹æ€§ï¼štry-with-resourcesï¼Œå®ƒè®©èµ„æºçš„é‡Šæ”¾ï¼ˆæ¯”å¦‚å…³é—­æ–‡ä»¶ã€ç½‘ç»œè¿æ¥ã€æ•°æ®åº“è¿æ¥ç­‰ï¼‰å˜å¾—æ›´è‡ªåŠ¨ã€æ›´å®‰å…¨ã€‚

åœ¨ Java 7 ä¹‹å‰ï¼Œå¦‚æœä½ æ‰“å¼€ä¸€ä¸ªèµ„æºï¼ˆæ¯”å¦‚æ–‡ä»¶æµï¼‰ï¼Œä½ å¿…é¡»æ‰‹åŠ¨åœ¨ finally å—ä¸­è°ƒç”¨ .close() æ¥é‡Šæ”¾å®ƒï¼š
è¿™ç§å†™æ³•åˆé•¿åˆå®¹æ˜“å‡ºé”™ï¼ˆæ¯”å¦‚ä½ å¿˜äº† close()ï¼Œæˆ– close() æŠ›å¼‚å¸¸æ²¡å¤„ç†å¥½ï¼‰ã€‚


```java
FileOutputStream out = null;
try {
    out = new FileOutputStream("myfile.dat");
    out.write(123);
} catch (IOException e) {
    e.printStackTrace();
} finally {
    if (out != null) {
        try {
            out.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```


Java 7 çš„æ”¹è¿›ï¼štry-with-resources
```java
try (FileOutputStreamout = new FileOutputStream("myfile.dat");){
	out.write(123);
} catch (IOExceptione) {
	e.printStackTrace();
}
```
â˜‘ï¸ è‡ªåŠ¨è°ƒç”¨ .close()ï¼Œå³ä½¿å‘ç”Ÿå¼‚å¸¸ä¹Ÿèƒ½å…³é—­
â˜‘ï¸ å†™æ³•ç®€æ´æ˜äº†
â˜‘ï¸ æ›´å®‰å…¨ï¼ˆé˜²æ­¢èµ„æºæ³„éœ²ï¼‰

try (...) é‡Œé¢çš„å˜é‡å¿…é¡»æ˜¯å®ç°äº† AutoCloseable æ¥å£çš„ç±»ï¼ˆå¦‚ï¼šFileInputStream, BufferedReader, Connection ç­‰ï¼‰ã€‚

---
ä½ å¯ä»¥åœ¨æ‹¬å·ä¸­æ”¾ å¤šä¸ªèµ„æºï¼Œç”¨åˆ†å· ; åˆ†éš”ã€‚
We can also have more than one resource in the try-with-resources block. In that case, we separate them with semicolons:
`try(<resource1>;â€¦;<resourceN>;){â€¦} catch(â€¦){â€¦} finally{â€¦}`

```java
try (
    FileInputStream in = new FileInputStream("input.txt");
    FileOutputStream out = new FileOutputStream("output.txt")
) {
    int data;
    while ((data = in.read()) != -1) {
        out.write(data);
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

# 9 èŠ‚ç‚¹æµå’Œå¤„ç†æµ/åŒ…è£…æµ

æŒ‰ç…§æµæ˜¯å¦ç›´æ¥ä¸ç‰¹å®šçš„åœ°æ–¹(å¦‚ç£ç›˜ã€å†…å­˜ã€è®¾å¤‡ç­‰)ç›¸è¿ï¼Œåˆ†ä¸ºèŠ‚ç‚¹æµå’Œå¤„ç†æµä¸¤ç±»ã€‚
 
- èŠ‚ç‚¹æµï¼š
	- å¯ä»¥ä»æˆ–å‘ä¸€ä¸ªç‰¹å®šçš„åœ°æ–¹ï¼ˆèŠ‚ç‚¹, æ–‡ä»¶ç±»å‹çš„èŠ‚ç‚¹, æˆ–è€… æ•°ç»„ç±»å‹çš„èŠ‚ç‚¹ï¼‰è¯»å†™æ•°æ®ã€‚å¦‚FileReader
- å¤„ç†æµ/åŒ…è£…æµ
	- ä¸å†æ˜¯åªå¯¹äºä¸€ä¸ªæ–‡ä»¶è¯»å–äº†. å¯ä»¥æ˜¯ä»»æ„çš„èŠ‚ç‚¹æµ.
	- æ˜¯å¯¹ä¸€ä¸ªå·²å­˜åœ¨çš„æµçš„javaclass çš„ è¿æ¥å’Œå°è£…ï¼Œé€šè¿‡æ‰€å°è£…çš„æµçš„åŠŸèƒ½è°ƒç”¨å®ç°æ•°æ®è¯»å†™ã€‚
		- å¦‚BufferedReader å°±æ˜¯ Reader class çš„å­ç±», å¦‚BufferedReader ä¸­å«æœ‰ä¸€ä¸ª Reader è¿™ä¸ªç±»çš„ priavate attributeã€‚å¤„ç†æµçš„æ„é€ æ–¹æ³•æ€»æ˜¯è¦å¸¦ä¸€ä¸ªå…¶ä»–çš„æµå¯¹è±¡åšå‚æ•°ã€‚ä¸€ä¸ªæµå¯¹è±¡ç»è¿‡å…¶ä»–æµçš„å¤šæ¬¡åŒ…è£…ï¼Œç§°ä¸ºæµçš„é“¾æ¥ã€‚
	- å­ç±»é‡Œé¢å£°æ˜ä¸€ä¸ªçˆ¶ç±»då¯¹è±¡, ä½ å¯ä»¥æŒ‡å‘è¿™ä¸ªå±æ€§çš„ä»»ä½•å­ç±», (å‘ä¸Šè½¬å‹).  æ¥æ¥å—è¯¥çˆ¶ç±»ä¸‹çš„æ‰€æœ‰å­ç±»

![](https://img-blog.csdnimg.cn/69fe3381b79c4190a16f975f27fc859e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aWI5pav5p2O5YWI55Sf,size_20,color_FFFFFF,t_70,g_se,x_16)

![](https://img-blog.csdnimg.cn/56dcd3cd45cf4af4ada62f0292c71cdf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aWI5pav5p2O5YWI55Sf,size_16,color_FFFFFF,t_70,g_se,x_16)

![](image/Pasted%20image%2020230420215442.png)

## 9.1 åŒºåˆ«å’Œè”ç³»
ï¼ˆ1ï¼‰èŠ‚ç‚¹æµæ˜¯åº•å±‚æµ/ä½çº§æµï¼Œç›´æ¥è·Ÿæ•°æ®æºç›¸æ¥ï¼›
ï¼ˆ2ï¼‰å¤„ç†æµåŒ…è£…èŠ‚ç‚¹æµï¼Œæ—¢å¯ä»¥æ¶ˆé™¤ä¸åŒèŠ‚ç‚¹æµçš„å®ç°å·®å¼‚ï¼Œä¹Ÿå¯ä»¥æä¾›æ›´æ–¹ä¾¿çš„æ–¹æ³•æ¥å®ç°è¾“å…¥è¾“å‡ºï¼›
ï¼ˆ3ï¼‰å¤„ç†æµï¼ˆåŒ…è£…æµï¼‰å¯¹èŠ‚ç‚¹æµè¿›è¡ŒåŒ…è£…ï¼Œä½¿ç”¨äº† ä¿®é¥°å™¨è®¾è®¡æ¨¡å¼ï¼Œä¸ä¼šç›´æ¥äºæ•°æ®æºç›¸è¿ã€‚

å¤„ç†æµçš„åŠŸèƒ½æ³¨æ„ä½“ç°ä¸¤ä¸ªæ–¹é¢
1. æ€§èƒ½çš„æé«˜: æ³¨æ„ä»¥å¢åŠ ç¼“å†²çš„æ–¹å¼æ¥æé«˜è¾“å…¥è¾“å‡ºçš„æ•ˆç‡
2. æ“ä½œçš„è¾¹ç•Œ: å¤„ç†æµå¯èƒ½æä¾›äº†ä¸€ç³»åˆ—çš„è¾¹ç•Œçš„æ”¾æ¥æ¥ä¸€æ¬¡è¾“å…¥è¾“å‡ºå¤§æ‰¹é‡çš„æ•°æ®, ä½¿ç”¨æ›´åŠ çµæ´» 

## 9.2 å¸¸ç”¨çš„èŠ‚ç‚¹æµ
- çˆ¶ ç±» InputStream OutputStream Reader Writer
- æ–‡ ä»¶ *FileInputStream FileOutputStrean FileReader FileWriter æ–‡ä»¶è¿›è¡Œå¤„ç†çš„èŠ‚ç‚¹æµ 
- æ•° ç»„ *ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter* å¯¹æ•°ç»„è¿›è¡Œå¤„ç†çš„èŠ‚ç‚¹æµï¼ˆå¯¹åº”çš„ä¸å†æ˜¯æ–‡ä»¶ï¼Œè€Œæ˜¯å†…å­˜ä¸­çš„ä¸€ä¸ªæ•°ç»„ï¼‰
- å­—ç¬¦ä¸² *æ—  æ—  StringReader StringWriter* å¯¹å­—ç¬¦ä¸²è¿›è¡Œå¤„ç†çš„èŠ‚ç‚¹æµ
- ç®¡ é“ *PipedInputStream PipedOutputStream PipedReader PipedWriter* å¯¹ç®¡é“è¿›è¡Œå¤„ç†çš„èŠ‚ç‚¹æµ

## 9.3 å¸¸ç”¨å¤„ç†æµï¼ˆå…³é—­å¤„ç†æµä½¿ç”¨å…³é—­é‡Œé¢çš„èŠ‚ç‚¹æµï¼‰
- çˆ¶ ç±» InputStream OutputStream Reader Writer
- ç¼“å†²æµ *BufferedImputStrean BufferedOutputStream BufferedReader BufferedWriter* ----éœ€è¦çˆ¶ç±»ä½œä¸ºå‚æ•°æ„é€ ï¼Œå¢åŠ ç¼“å†²åŠŸèƒ½ï¼Œé¿å…é¢‘ç¹è¯»å†™ç¡¬ç›˜ï¼Œå¯ä»¥åˆå§‹åŒ–ç¼“å†²æ•°æ®çš„å¤§å°ï¼Œç”±äºå¸¦äº†ç¼“å†²åŠŸèƒ½ï¼Œæ‰€ä»¥å°±å†™æ•°æ®çš„æ—¶å€™éœ€è¦ä½¿ç”¨flushæ–¹æ³•å’¯
- è½¬æ¢æµ *InputStreamReader OutputStreamWriter*- è¦inputStream æˆ–OutputStreamä½œä¸ºå‚æ•°ï¼Œå®ç°ä»å­—èŠ‚æµåˆ°å­—ç¬¦æµçš„è½¬æ¢
- æ•°æ®æµ *DataInputStream DataOutputStream* -æä¾›å°†åŸºç¡€æ•°æ®ç±»å‹å†™å…¥åˆ°æ–‡ä»¶ä¸­ï¼Œæˆ–è€…è¯»å–å‡ºæ¥ï¼Œä¸ºä»€ä¹ˆè¦æœ‰è¿™ä¸ªæµå‘¢ï¼Ÿçœ‹è¿™æ ·çš„åˆ†æï¼Œå¦‚æœæ²¡æœ‰è¿™ç§æµçš„è¯ï¼Œæœ‰ä¸€ä¸ªlongï¼Œæœ¬èº« åªå 8ä¸ªå­—èŠ‚ï¼Œå¦‚æœæˆ‘è¦å†™å…¥åˆ°æ–‡ä»¶ï¼Œéœ€è¦è½¬æˆå­—ç¬¦ä¸²ï¼Œç„¶ååœ¨è½¬æˆå­—ç¬¦æ•°ç»„ï¼Œé‚£ç©ºé—´ä¼šå ç”¨å¾ˆå¤šï¼Œä½†æ˜¯æœ‰äº†è¿™ç§æµä¹‹åå°±å¾ˆæ–¹ä¾¿äº†ï¼Œç›´æ¥å°†è¿™8ä¸ªå­—èŠ‚å†™åˆ°æ–‡ä»¶å°±å®Œäº†ã€‚ã€‚æ˜¯ä¸æ˜¯æ—¢ èŠ‚çº¦äº†å†…å­˜ç©ºé—´æœ‰è®©ç¨‹åºå†™èµ·æ¥æ›´åŠ æ–¹ä¾¿ç®€å•äº†å‘ã€‚å†™å€’æ˜¯å¾ˆç®€å•ï¼Œä½†æ˜¯è¯»å–çš„æ—¶å€™å°±æ³¨æ„äº†ï¼Œæ ¹æ®è¯»å–çš„æ•°æ®ç±»å‹ï¼ŒæŒ‡é’ˆä¼šå¾€ä¸‹ç§»ï¼Œæ‰€ä»¥ä½ å†™çš„é¡ºåºå¿…é¡»è¦å’Œè¯»çš„é¡ºåºä¸€è‡´æ‰èƒ½å®Œæˆä½ æ­£ç¡®çš„éœ€æ±‚ã€‚
- å¯¹è±¡æµ *ObjectInputStream ObjectOutputStream

## 9.4 å…¶ä»–
- é¡ºä¾¿ç ”ç©¶åºåˆ—åŒ–---å°†å¯¹è±¡æ‰€åœ¨çš„ç±»å‹å…¨éƒ¨è½¬æ¢æˆäºŒè¿›åˆ¶ï¼Œç„¶åå†™å…¥åˆ°ä»‹è´¨ä¸­å»
	- transientå…³é”®å­—--ä¿®é¥°æˆå‘˜å˜é‡ï¼Œä¸å†™å…¥è¯¥æˆå‘˜å˜é‡
	- Serializableæ¥å£--è¡¨ç¤ºæ¥å£ï¼Œæ€æ ·å®ç°çš„å‘¢ï¼Œåœ¨åºåˆ—åŒ–ä¹‹å‰ï¼Œé¦–å…ˆåˆ¤æ–­ ï¼ˆå¯¹è±¡ instanceof Serializableï¼‰å¦‚æœè¿”å›trueåˆ™æ‰§è¡Œåºåˆ—åŒ–ï¼Œå¦è€…æŠ›å‡ºå¼‚å¸¸ï¼Œå¹¶ä¸”é‡Œé¢æœ‰ä¸€ä¸ªIDï¼Œæ˜¯ç”¨æ¥å¿«é€Ÿ
	- æŸ¥æ‰¾æŸä¸ªå¯¹è±¡çš„æ—¶å€™ä½¿ç”¨çš„
	- Externalizableæ¥å£--å¤–éƒ¨åŒ–æ¥å£ï¼›ä»–æ˜¯Serializableæ¥å£çš„å­æ¥å£ï¼Œèƒ½æ‰‹åŠ¨æ§åˆ¶åºåˆ—åŒ–çš„æ–¹å¼
	- ä¸ºä»€ä¹ˆè¦ç”¨writeUTF()--å› ä¸ºè¿™ç§æ–¹å¼æ˜¯æŒ‰ç…§utf-8æ¥å†™å…¥çš„ï¼Œè€Œé»˜è®¤æ–¹å¼æ˜¯utf-16åªæ˜¯èŠ‚çœç©ºé—´è€Œå·² 


# 10 æ¨¡æ‹Ÿä¿®é¥°å™¨è®¾è®¡æ¨¡å¼

```JAVA
    //Reader_ç±»
    public abstract class Reader_ { //æŠ½è±¡ç±»
        public void readFile() {}
        public void readString() {}

        //åœ¨Reader_ æŠ½è±¡ç±»ï¼Œä½¿ç”¨readæ–¹æ³•ç»Ÿä¸€ç®¡ç†.
        //åé¢åœ¨è°ƒç”¨æ—¶ï¼Œåˆ©äºå¯¹è±¡åŠ¨æ€ç»‘å®šæœºåˆ¶ï¼Œ ç»‘å®šåˆ°å¯¹åº”çš„å®ç°å­ç±»å³å¯.
        //public abstract void read();
    }

    //FileReader_ç±». æŠŠè¿™ä¸ªç±»å½“ç§°èŠ‚ç‚¹æµ
    public class FileReader_ extends Reader_ {

        public void readFile() {
            System.out.println("å¯¹æ–‡ä»¶è¿›è¡Œè¯»å–...");
        }
    }

    // StringReader_ç±». æŠŠè¿™ä¸ªç±»å½“ç§°èŠ‚ç‚¹æµ
    public class StringReader_ extends Reader_ {
        public void readString() {
            System.out.println("è¯»å–å­—ç¬¦ä¸²..");
        }

    }

    // BufferedReader_ç±». æŠŠè¿™ä¸ªç±»å½“ç§°å¤„ç†æµ
    public class BufferedReader_ extends Reader_ {

        private Reader_ reader_; //å±æ€§æ˜¯ Reader_ç±»å‹

        //æ¥æ”¶Reader_ å­ç±»å¯¹è±¡
        public BufferedReader_(Reader_ reader_) {
            this.reader_ = reader_;
        }

        public void readFile() { //å°è£…ä¸€å±‚
            reader_.readFile();
        }

        //è®©æ–¹æ³•æ›´åŠ çµæ´»ï¼Œ å¤šæ¬¡è¯»å–æ–‡ä»¶, æˆ–è€…åŠ ç¼“å†²byte[] ....
        public void readFiles(int num) {
            for (int i = 0; i < num; i++) {
                reader_.readFile();
            }
        }

        //æ‰©å±• readString, æ‰¹é‡å¤„ç†å­—ç¬¦ä¸²æ•°æ®
        public void readStrings(int num) {
            for (int i = 0; i < num; i++) {
                reader_.readString();
            }
        }

    }

    //Test_ç±»
    public class Test_ {
        public static void main(String[] args) {

			//  FileReader_
            BufferedReader_ bufferedReader_ = new BufferedReader_(new FileReader_());
            bufferedReader_.readFiles(10);
            //bufferedReader_.readFile();
            
            //Serializable
            //Externalizable
            
            //ObjectInputStream
            //ObjectOutputStream
            
            //è¿™æ¬¡å¸Œæœ›é€šè¿‡ BufferedReader_ å¤šæ¬¡è¯»å–å­—ç¬¦ä¸²
            BufferedReader_ bufferedReader_2 = new BufferedReader_(new StringReader_());
            bufferedReader_2.readStrings(5);
        }
    }

```


# 11 IOException

Alle Methoden dieser Lerneinheit sind so deklariert, dass sie Ausnahmen (exceptions) vom Typ IOException auslÃ¶sen. Fehlerhafte Eingabe- und Ausgabeoperationen kÃ¶nnen so mit Hilfe dieser Klasse vom Programm aufgefangen werden.

Die Klasse IOException ist im Paket (package) java.io enthalten. Sie erbt ihre Attribute (fields) und Methoden von den Klassen Exception und Throwable aus dem Paket java.lang. 

![](image/Pasted%20image%2020230424102501.png)
 	

Die beschriebenen Ausnahmen werden im Programm entweder mit try und catch aufgefangen

```java
try {
    // Ein- und Ausgabe-Operationen werden programmiert
} catch (IOException e) {
    // Anweisungen, die ausgefï¿½hrt werden, wenn 
    // Ausnahmesituation eintritt
}  
```


oder einfach weitergeleitet, wenn der Methodenkopf (method header) mit dem SchlÃ¼sselwort (keyword) throws erweitert wird.

`public static void main(String[] args) throws IOException {``

Wenn Sie das Modul Programmieren I belegt haben, dann kÃ¶nnen Sie sich in Ihren Unterlagen noch einmal die entsprechenden Kapitel in der Lerneinheit "Ausnahmen" ansehen.