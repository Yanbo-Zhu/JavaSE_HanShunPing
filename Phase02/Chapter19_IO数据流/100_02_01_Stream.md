

# 1 Java Streams


1  **Was sind die Vorteile von Java Streams im Vergleich zu traditionellen Schleifen und Iterationen?**

**Antwort auf Deutsch:**

Java Streams bieten mehrere Vorteile gegenüber traditionellen Schleifen und Iterationen:

1. **Kürzerer und ausdrucksstärkerer Code** – Streams ermöglichen eine funktionale Programmierung mit weniger Codezeilen.
    
2. **Bessere Lesbarkeit und Wartbarkeit** – Der Code wird deklarativer und klarer, was getan werden soll (nicht wie).
    
3. **Einfache Parallelisierung** – Mit `.parallelStream()` kann die Verarbeitung einfach auf mehrere Threads verteilt werden.
    
4. **Lazy Evaluation** – Streams führen Operationen nur aus, wenn sie benötigt werden (z. B. bei terminalen Operationen).
    
5. **Keine manuelle Kontrolle über Schleifenindex oder Iterator** – weniger fehleranfällig.


Stream API hat viele Methode, die schon vorimplementiert werden 


----


2  Erklären Sie den Unterschied zwischen einem Stream und einer Collection in Java.

**Antwort auf Deutsch:**

- Eine **Collection** ist eine Datenstruktur, die Elemente speichert (z. B. `List`, `Set`). Sie repräsentiert eine **statische Datenmenge**.
    
- Ein **Stream** ist eine **abstrakte Folge von Daten**, die aus einer Collection erzeugt werden kann. Ein Stream speichert keine Daten, sondern **verarbeitet** sie – oft **on-the-fly**.
    
- Streams sind **einmalig verwendbar** und unterstützen **Lazy Evaluation** und **funktionale Operationen** wie `map`, `filter`, `reduce`.



----

3 

**Was sind die Hauptunterschiede zwischen intermediären und terminalen Operationen in Streams?**

**Antwort auf Deutsch:**

- **Intermediäre Operationen** (z. B. `map`, `filter`, `sorted`) geben **einen neuen Stream** zurück. Sie sind **lazy**, das heißt, sie werden erst bei Ausführung einer terminalen Operation ausgewertet.
    
- **Terminale Operationen** (z. B. `collect`, `forEach`, `count`) **beenden die Stream-Verarbeitung** und lösen die Ausführung der gesamten Stream-Pipeline aus.
    
- **Ein Stream kann nur eine terminale Operation haben**, danach ist er nicht mehr verwendbar.





## 1.1 Collectors-Objekt in Java Streams

Was bietet das Collectors-Objekt in Java Streams und warum ist es notwendig?

`Collectors` 是 Java Stream API 中的一个工具类，它提供了一系列**收集操作（collecting operations）**，可以将 Stream 中的元素**转换成其他数据结构**，例如：

- 转成 `List`、`Set`、`Map`；
    
- 进行聚合（如求和、计数、平均）；
    
- 按条件分组（grouping）或划分（partitioning）；
    

这些操作是 Stream 处理中最后的重要一步。没有 `Collectors`，很多 Stream 的结果无法方便地转为我们想要的结构。

Hier sind einige der häufigsten Methoden, die vom `Collectors`-Objekt bereitgestellt werden:

1. `toList()` – Sammelt die Elemente in eine `List`.
    
2. `toSet()` – Sammelt die Elemente in ein `Set`.
    
3. `toMap(keyMapper, valueMapper)` – Sammelt Elemente in eine `Map`.
    
4. `counting()` – Gibt die Anzahl der Elemente zurück.
    
5. `summarizingInt()`, `summarizingDouble()` – Gibt Statistiken wie Summe, Durchschnitt, Minimum und Maximum.
    
6. `joining(delimiter)` – Verbindet Strings mit einem Trennzeichen.
    
7. `groupingBy()` – Gruppiert die Elemente nach einem bestimmten Kriterium.
    
8. `partitioningBy()` – Teilt die Elemente in zwei Gruppen (true/false) auf.
    
9. `maxBy()`, `minBy()` – Findet das größte/kleinste Element nach einem Comparator.
    
10. `reducing()` – Führt eine Reduktion durch (ähnlich wie `reduce()` im Stream selbst).


### 1.1.1 Beipsiel 

Gegeben ist die Klasse Player welche einen Fußballspieler darstellt. Ein Spieler hat die
Attribute name vom Typ String, team vom Typ String, goals vom Typ int und assists
vom Typ int. In der main-Methode haben Sie eine Liste der 25 besten Torschützen aus der
polnischen Ekstraklasa aus der Saison 21/22. Implementieren Sie die folgenden Funktionen
mittels Streams.


Player.java
```java
import java.util.ArrayList;  
import java.util.Arrays;  
import java.util.List;  
  
public class Player {  
    String name;  
    String team;  
    int goals;  
    int assists;  
  
    public Player(String name, String team, int goals, int assists) {  
        this.name = name;  
        this.team = team;  
        this.goals = goals;  
        this.assists = assists;  
    }  
  
    // alternative solution  
    public int getAssists() {  
        return this.assists;  
    }  
  
    @Override  
    public String toString() {  
        return this.name + " - Goals: " + this.goals + " - Assists: " + this.assists + " - Team: " + this.team;  
    }  
  
    static List<Player> bestplayers = new ArrayList<>(Arrays.asList(  
            new Player("Ivi López", "Rakow Czestochowa", 20, 7),  
            new Player("Mikael Ishak", "Lech Poznan", 18, 6),  
            new Player("Karol Angielski", "Radomiak Radom", 18, 1),  
            new Player("João Amarai", "Lech Poznan", 14, 8),  
            new Player("Lukasz Zwolinski", "Lechia Gdansk", 14, 0),  
            new Player("Lukasz Sekulski", "Wisla Plock", 13, 3),  
            new Player("Patryk Szysz", "Zaglebie Lubin", 11, 5),  
            new Player("Luka Zahovic", "Pogon Szczecin", 11, 5),  
            new Player("Muris Mesanovic", "Bruk-Bet Termalica Nieciecza", 11, 2),  
            new Player("Erik Expósito", "Slask Wroclaw", 11, 2),  
            new Player("Bartosz Spiaczka", "Gornik Leczna", 11, 0),  
            new Player("Flávio Paixão", "Lechia Gdansk", 10, 7),  
            new Player("Jakub Kaminski", "Lech Poznan", 9, 8),  
            new Player("Vladislavs Gutkovskis", "Rakow Czestochowa", 9, 6),  
            new Player("Kamil Grosicki", "Pogon Szczecin", 9, 6),  
            new Player("Lukas Podolski", "Górnik Zabrze", 9, 4),  
            new Player("Krzysztof Kubica", "Górnik Zabrze", 9, 3),  
            new Player("Piotr Wlazlo", "Bruk-Bet Termalica Nieciecza", 9, 2),  
            new Player("Adam Zrelak", "Warta Poznan", 9, 2),  
            new Player("Jesús Imaz", "Jagiellonia Bialystok", 9, 2),  
            new Player("Tomas Pekhart", "Legia Warszawa", 9, 1),  
            new Player("Bartosz Nowak", "Górnik Zabrze", 8, 4),  
            new Player("Jesús Jiménez", "Górnik Zabrze", 8, 4),  
            new Player("Grzegorz Tomasiewicz", "Stal Mielec", 8, 2),  
            new Player("Pelle van Amersfoort", "Cracovia", 8, 1)  
    ));  
}

```


Counter.java
``` java
import java.util.Arrays;  
import java.util.List;  
  
public class Counter {  
    private int counter;  
  
    public Counter(int x) {  
        this.counter = x;  
    }  
  
    public int getCounter() {  
        return this.counter;  
    }  
  
    public Counter increaseCounter() {  
        this.counter++;  
        return this;  
    }  
  
    public boolean isEven() {  
        return this.counter % 2 == 0;  
    }  
  
    public static void lambdaStream(List<Integer> nums) {  
        nums.stream()  
            .map(i -> new Counter(i))  
            .filter(c -> c.isEven())  
            .map(c -> c.increaseCounter())  
            .map(c -> c.getCounter())  // without this line, the output would be Counter objects, not integers values  
            .forEach(c -> System.out.println(c));  
    }  
  
    public static void methodRefStream(List<Integer> nums) {  
        //TODO: Implement the method chain from lambdaStreams() using method references  
        nums.stream()  
//                .map(i -> new Counter(i))  
//                .filter(c -> c.isEven())  
//                .map(c -> c.increaseCounter())  
//                .map(c -> c.getCounter())  // without this line, the output would be Counter objects, not integers values  
//                .forEach(c -> System.out.println(c));  
                .map(Counter::new)  // Create Counter objects from integers . constructor reference  
                .filter(Counter::isEven)  // Filter even counters using method reference  
                .map(Counter::increaseCounter)  // Increase counter using method reference  
                .map(Counter::getCounter)  // Get the counter value using method reference  
                .forEach(System.out::println);  // Print each counter value using method reference  
  
    }  
  
    public static void main(String[] args) {  
        List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5, 6);  
        lambdaStream(nums);  
        methodRefStream(nums);  
    }  
}
```


# 2 Methodenreferenzen

Method References  is reference of method.   Through Method References , the method can be directly invoked 

Was sind Methodenreferenzen und welchen Vorteil haben sie gegenüber Lambda-Ausdrücken?

**Methodenreferenzen** (Method References) sind eine verkürzte Schreibweise für Lambda-Ausdrücke, wenn eine Methode direkt aufgerufen wird.

Beispiel:
```
// Lambda-Ausdruck:
list.forEach(x -> System.out.println(x));

// Methodenreferenz:
list.forEach(System.out::println);

```


**Vorteile gegenüber Lambda-Ausdrücken:**

1. **Kürzerer und lesbarer Code** – Methode muss nicht umständlich mit Parametern beschrieben werden.
    
2. **Mehr Wiederverwendung vorhandener Methoden** – vorhandene Methoden können direkt referenziert werden.
    
3. **Weniger Fehleranfälligkeit** – da keine Parameterlogik neu geschrieben werden muss.


## 2.1 Beispiel 


Schreiben Sie die sogenannte “Method-Chain” in der Klasse Counter so um, dass alle
Lambda-Ausdrücke durch Methodenreferenzen ersetzt werden.


```java
import java.util.Arrays;  
import java.util.List;  
  
public class Counter {  
    private int counter;  
  
    public Counter(int x) {  
        this.counter = x;  
    }  
  
    public int getCounter() {  
        return this.counter;  
    }  
  
    public Counter increaseCounter() {  
        this.counter++;  
        return this;  
    }  
  
    public boolean isEven() {  
        return this.counter % 2 == 0;  
    }  
  
    public static void lambdaStream(List<Integer> nums) {  
        nums.stream()  
            .map(i -> new Counter(i))  
            .filter(c -> c.isEven())  
            .map(c -> c.increaseCounter())  
            .map(c -> c.getCounter())  // without this line, the output would be Counter objects, not integers values  
            .forEach(c -> System.out.println(c));  
    }  
  
    public static void methodRefStream(List<Integer> nums) {  
        //TODO: Implement the method chain from lambdaStreams() using method references  
        nums.stream()  
//                .map(i -> new Counter(i))  
//                .filter(c -> c.isEven())  
//                .map(c -> c.increaseCounter())  
//                .map(c -> c.getCounter())  // without this line, the output would be Counter objects, not integers values  
//                .forEach(c -> System.out.println(c));  
                .map(Counter::new)  // Create Counter objects from integers . constructor reference  
                .filter(Counter::isEven)  // Filter even counters using method reference  
                .map(Counter::increaseCounter)  // Increase counter using method reference  
                .map(Counter::getCounter)  // Get the counter value using method reference  
                .forEach(System.out::println);  // Print each counter value using method reference  
  
    }  
  
    public static void main(String[] args) {  
        List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5, 6);  
        lambdaStream(nums);  
        methodRefStream(nums);  
    }  
}
```



