
# 1 Set
## 1.1 Set接口和常用方法

(1)无序(添加和取出的顺序不一致)，没有索引
(2)不允许元素重复，所以最多包含一个null
(3)JDK API中Set接口的实现类有:
![](image/Pasted%20image%2020230430205104.png)
和List 接口一样, Set 接口也是Collection 的子接口，因此，常用方法和Collection 接口一样.


## 1.2 Set接口的遍历方式

同Collection的遍历方式一样，因为Set接口是Collection接口的子接口。
1.可以使用迭代器
2.增强for循环
3.不能使用索引的方式来获取


## 1.3 Set 接口的常用方法举例

```java
package com.hspedu.set_;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
/**
* @author 韩顺平
* @version 1.0
*/
@SuppressWarnings({
    "all"
})
public class SetMethod {
    public static void main(String[] args) {
        //老韩解读
        //1. 以Set 接口的实现类HashSet 来讲解Set 接口的方法
        //2. set 接口的实现类的对象(Set 接口对象), 不能存放重复的元素, 可以添加一个null
        //3. set 接口对象存放数据是无序(即添加的顺序和取出的顺序不一致)
        //4. 注意：取出的顺序的顺序虽然不是添加的顺序，但是他的固定.
        Set set = new HashSet();
        set.add("john");
        set.add("lucy");
        set.add("john"); //重复
        set.add("jack");
        set.add("hsp");
        set.add("mary");
        set.add(null); //
        set.add(null); //再次添加null
        for (int i = 0; i < 10; i++) {
            System.out.println("set=" + set);
        }
        //遍历
        //方式1： 使用迭代器
        韩顺平循序渐进学Java 零基础
        第642页
        System.out.println("=====使用迭代器====");
        Iterator iterator = set.iterator();
        while (iterator.hasNext()) {
            Object obj = iterator.next();
            System.out.println("obj=" + obj);
        }
        set.remove(null);
        //方式2: 增强for
        System.out.println("=====增强for====");
        for (Object o: set) {
            System.out.println("o=" + o);
        }
        //set 接口对象，不能通过索引来获取
    }
}
```


# 2 HashSet

## 2.1 HashSet的全面说明

(1)HashSet实现了Set接口
(2)HashSet实际上是HashMap
```java
    public HashSet() {
        map = new HashMap<>();
    }

//add也用的map的方法？？？？
public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }

// key值默认是PRESENT
   // Dummy value to associate with an Object in the backing Map
    private static final Object PRESENT = new Object();


```
(3)可以存放null值，但是只能有一个null
(4)HashSet不保证元素是有序的，取决于hash后，再确定索引的结果(不保证元素存放和取出顺序一致)
(5)不能有重复元素/对象。在前面Set接口使用已经讲过了
(6)在存储对象进HashSet时，对象重写equals方法一定要重写hashCode方法，不然就会出现两个对象里面的数据一模一样，但是都可以存进HashSet集合中，因为如果没有重写HashCode方法，对象会使用父类Object类的hashCode方法，而Object的HashCode方法是根据地址来计算的，一定不会一样
使用的比较地址就是用的hashcode()


```java
package com.hspedu.set_;
import java.util.HashSet;
import java.util.Set;
/**
 * @author 韩顺平
 * @version 1.0
 */
@SuppressWarnings({
    "all"
})
public class HashSet_ {
    public static void main(String[] args) {
        //老韩解读
        //1. 构造器走的源码
        /*
        public HashSet() {
        map = new HashMap<>();
        }
        韩顺平循序渐进学Java 零基础
        第644页
        2. HashSet 可以存放null ,但是只能有一个null,即元素不能重复
        */
        Set hashSet = new HashSet();
        hashSet.add(null);
        hashSet.add(null);
        System.out.println("hashSet=" + hashSet);
    }
}
```

## 2.2 HashSet 案例说明: 数组链表模拟

HashSet的底层是HashMap,HashMap的底层是数组加链表/红黑树

```java
package com.hspedu.set_;
import java.util.HashSet;
/**
 * @author 韩顺平
 * @version 1.0
 */
@SuppressWarnings({
    "all"
})
public class HashSet01 {
    public static void main(String[] args) {
        HashSet set = new HashSet();
        韩顺平循序渐进学Java 零基础
        第645页
        //说明
        //1. 在执行add 方法后，会返回一个boolean 值
        //2. 如果添加成功，返回true, 否则返回false
        //3. 可以通过remove 指定删除哪个对象
        System.out.println(set.add("john")); //T
        System.out.println(set.add("lucy")); //T
        System.out.println(set.add("john")); //F
        System.out.println(set.add("jack")); //T
        System.out.println(set.add("Rose")); //T
        set.remove("john");
        System.out.println("set=" + set); //3 个
        //
        set = new HashSet();
        System.out.println("set=" + set); //0
        //4 Hashset 不能添加相同的元素/数据?
        set.add("lucy"); //添加成功
        set.add("lucy"); //加入不了
        set.add(new Dog("tom")); //OK
        set.add(new Dog("tom")); //Ok
        System.out.println("set=" + set);
        //在加深一下. 非常经典的面试题.
        韩顺平循序渐进学Java 零基础
        第646页
        //看源码，做分析， 先给小伙伴留一个坑，以后讲完源码，你就了然
        //去看他的源码，即add 到底发生了什么?=> 底层机制.
        set.add(new String("hsp")); //ok
        set.add(new String("hsp")); //加入不了.
        System.out.println("set=" + set);
    }
}
class Dog { //定义了Dog 类
    private String name;
    public Dog(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return "Dog{" +
            "name='" + name + '\'' +
            '}';
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/226c8a96dddd3eee5bc0f88a5c65b733.png)

在hashmap底层，如果一条链表的节点的个数达到一定数量，就会变成红黑树，因为红黑树的存取效率更高

**为什么不直接把数据放在一个数组里面？**  
答：数组的效率太低了


## 2.3 HashSet的底层机制/HashSet扩容机制

分析:HashSet底层是HashMap，HashMap底层是(数组+链表+红黑树)
1. HashSet底层是HashMap
2. 添加一个元素时，先得到hash值，会转成索引值
3. 找到存储数据表table，看这个索引位置是否已经存放的有元素
4. 如果没有，直接加入
5. 如果有，调用equals比较，如果相同，就放弃添加，如果不相同，则添加到最后
6. 在JAVA 8 中，如果一条链表的元素个数，到达TREEIFY_THRESHOLD(默认是8)，并且table的大小>= MIN_TREEIFY_CAPACITY(默认64)就进行树化(红黑树)


如果单条链表节点超过了8但是总的节点数没达到64怎么办了？
答：扩容，按2倍扩


## 2.4 HashSet源码分析

```java
package com.hspedu.set_;

import java.util.HashSet;

/**
 * @author 韩顺平
 * @version 1.0
 */
@SuppressWarnings({"all"})
public class HashSetSource {
    public static void main(String[] args) {

        HashSet hashSet = new HashSet();
        hashSet.add("java");//到此位置，第1次add分析完毕.
        hashSet.add("php");//到此位置，第2次add分析完毕
        hashSet.add("java");
        System.out.println("set=" + hashSet);

        /*
        老韩对HashSet 的源码解读
        1. 执行 HashSet()
            public HashSet() {
                map = new HashMap<>();
            }
        2. 执行 add()
           public boolean add(E e) {//e = "java"
                return map.put(e, PRESENT)==null;//(static) PRESENT = new Object();
           }
         3.执行 put() , 该方法会执行 hash(key) 得到key对应的hash值 算法h = key.hashCode()) ^ (h >>> 16)
             public V put(K key, V value) {//key = "java" value = PRESENT 共享
                return putVal(hash(key), key, value, false, true);
            }
         4.执行 putVal
         final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
                Node<K,V>[] tab; Node<K,V> p; int n, i; //定义了辅助变量
                //table 就是 HashMap 的一个数组，类型是 Node[]
                //if 语句表示如果当前table 是null, 或者 大小=0
                //就是第一次扩容，到16个空间.
                if ((tab = table) == null || (n = tab.length) == 0)
                    n = (tab = resize()).length;

                //(1)根据key，得到hash 去计算该key应该存放到table表的哪个索引位置
                //并把这个位置的对象，赋给 p
                //(2)判断p 是否为null
                //(2.1) 如果p 为null, 表示还没有存放元素, 就创建一个Node (key="java",value=PRESENT)
                //(2.2) 就放在该位置 tab[i] = newNode(hash, key, value, null)

                if ((p = tab[i = (n - 1) & hash]) == null)
                    tab[i] = newNode(hash, key, value, null);
                else {
                    //一个开发技巧提示： 在需要局部变量(辅助变量)时候，在创建
                    Node<K,V> e; K k; //
                    //如果当前索引位置对应的链表的第一个元素和准备添加的key的hash值一样
                    //并且满足 下面两个条件之一:
                    //(1) 准备加入的key 和 p 指向的Node 结点的 key 是同一个对象
                    //(2)  p 指向的Node 结点的 key 的equals() 和准备加入的key比较后相同
                    //就不能加入
                    if (p.hash == hash &&
                        ((k = p.key) == key || (key != null && key.equals(k))))
                        e = p;
                    //再判断 p 是不是一颗红黑树,
                    //如果是一颗红黑树，就调用 putTreeVal , 来进行添加
                    else if (p instanceof TreeNode)
                        e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
                    else {//如果table对应索引位置，已经是一个链表, 就使用for循环比较
                          //(1) 依次和该链表的每一个元素比较后，都不相同, 则加入到该链表的最后
                          //    注意在把元素添加到链表后，立即判断 该链表是否已经达到8个结点
                          //    , 就调用 treeifyBin() 对当前这个链表进行树化(转成红黑树)
                          //    注意，在转成红黑树时，要进行判断, 判断条件
                          //    if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY(64))
                          //            resize();
                          //    如果上面条件成立，先table扩容.
                          //    只有上面条件不成立时，才进行转成红黑树
                          //(2) 依次和该链表的每一个元素比较过程中，如果有相同情况,就直接break

                        for (int binCount = 0; ; ++binCount) {
                            if ((e = p.next) == null) {
                                p.next = newNode(hash, key, value, null);
                                if (binCount >= TREEIFY_THRESHOLD(8) - 1) // -1 for 1st
                                    treeifyBin(tab, hash);
                                break;
                            }
                            if (e.hash == hash &&
                                ((k = e.key) == key || (key != null && key.equals(k))))
                                break;
                            p = e;
                        }
                    }
                    if (e != null) { // existing mapping for key
                        V oldValue = e.value;
                        if (!onlyIfAbsent || oldValue == null)
                            e.value = value;
                        afterNodeAccess(e);
                        return oldValue;
                    }
                }
                ++modCount;
                //size 就是我们每加入一个结点Node(k,v,h,next), size++
                if (++size > threshold)
                    resize();//扩容
                afterNodeInsertion(evict);
                return null;
            }
         */

    }
}

```

### 2.4.1 不仅打印顺序和插入顺序不一样，也不能添加重复元素
  
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/257e4eac276f7ae31291bf597ba152a2.png)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/395a67d684df9c804be714bd043339ee.png)

看到没有进来了，也就是说hashset底层的hash函数是利用了我们的key的hashcode()函数的，这里可以思考一下为什么重写了equals还要重写hashcode();
```java
  static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }

```

这里无符号右移16位，主要是为了防止冲突，让不同的key得到不同的hash值，避免碰撞
看到了吗，key=null的时候返回0，这也就可以解释为什么你往set里面添加null元素的时候，你再遍历，输出的第一个值就是null，即null放在第一个位置


### 2.4.2 我们来拆解putVal方法

table是一个Node<K,V>类型的数组
```java
transient Node<K,V>[] table;
```
 
他如果table为空数组，就先扩容
```java
if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;

```
 
接下来进入resize函数
先把table赋值给一个oldTab,然后计算这个oldTab的大小关系
```java
Node<K,V>[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;

```
 
当我们第一次扩容，oldCap=0，执行下面的代码
```java
  else {               // zero initial threshold signifies using defaults
            newCap = DEFAULT_INITIAL_CAPACITY;
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }

```

newCap表示新开辟的数组空间
newThr是临界值，表示下一次数组里面的容量达到了这么多之后就要进行扩容了，初始容量16的时候，用来12个空间我们就要扩容了
加载因子 DEFAULT_LOAD_FACTOR是为了在空间利用率和哈希冲突之间平衡的一个参数

```java
 static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
 static final float DEFAULT_LOAD_FACTOR = 0.75f;
```

至于16为什么写成1<<4,有注释，提醒我们数组大小必须是2的n次方
```java
/**
     * The default initial capacity - MUST be a power of two.
     */

```

然后根据newCap初始化一个newTab并赋值给table
```java
 Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
        table = newTab;

```


### 2.4.3 ###
接下来扩容之后，根据key计算出来的hash值来计算新的节点在tab中的索引，并把这个位置的对象赋值给辅助变量p
如果p为null，说明这个位置还没有存放过元素，就根据key,value创建一个node放在这个位置,为甚要把hash也存进去？因为将来要进行比较
```java
if ((p = tab[i = (n - 1) & hash]) == null)
            tab[i] = newNode(hash, key, value, null);

```

++modCount代表修改了一次
 ++modCount;

下面这个方法在hashMap里面是空的，没有作用，只是为了让HashMap的子类比如LinkedHashMap去实现
  void afterNodeInsertion(boolean evict) { }

### 2.4.4 最后的return null其实是代表添加成功
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/91fa7f1fb7e6cd86f3baca0ed7c72eda.png)

如下是hashSet的add方法，当putVal方法返回空，add会返回true
```java
  public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }


public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/af36c1ec8b287db37315713b66f3e3df.png)

对于添加两个相同元素的情况，如此下代码，直接执行 e.value = value;即保留key，覆盖value，并把就得value值返回。
```java
  if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }

```


下面这段代码是当判断到新插入的元素产生哈希冲突后，遍历该数组位置上的链表，如果在链表上有重复元素，就停止加入，如果走到链表的尾部都还没有重复元素，就把新插入的元素挂载到链表的尾部，

而且可以看出，jdk1.8对于链表用的是尾插法
```java
 for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;
                }
```

如果添加元素之后，链表的节点数大于等于了（8个）TREEIFY_THRESHOLD - 1，就把当前这个链表转化成红黑树转成红黑树时会判断，如果节点数小于64，不会进行树化，而是扩容）
```java
if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)
            resize();
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/7d2e72123a35f83fb5a114e8a0dd452d.png)

### 2.4.5 
测试链表转红黑树,自定义类，重写hashcode函数，返回一个固定值就可以了
```java
package com.hspedu.set_;

import java.util.HashSet;
import java.util.Objects;

/**
 * @author 韩顺平
 * @version 1.0
 */
@SuppressWarnings({"all"})
public class HashSetIncrement {
    public static void main(String[] args) {
        /*
        HashSet底层是HashMap, 第一次添加时，table 数组扩容到 16，
        临界值(threshold)是 16*加载因子(loadFactor)是0.75 = 12
        如果table 数组使用到了临界值 12,就会扩容到 16 * 2 = 32,
        新的临界值就是 32*0.75 = 24, 依次类推

         */
        HashSet hashSet = new HashSet();
//        for(int i = 1; i <= 100; i++) {
//            hashSet.add(i);//1,2,3,4,5...100
//        }
        /*
        在Java8中, 如果一条链表的元素个数到达 TREEIFY_THRESHOLD(默认是 8 )，
        并且table的大小 >= MIN_TREEIFY_CAPACITY(默认64),就会进行树化(红黑树),
        否则仍然采用数组扩容机制

         */

//        for(int i = 1; i <= 12; i++) {
//            hashSet.add(new A(i));//
//        }


        /*
            当我们向hashset增加一个元素，-> Node -> 加入table , 就算是增加了一个size++

         */

        for(int i = 1; i <= 7; i++) {//在table的某一条链表上添加了 7个A对象
            hashSet.add(new A(i));//
        }

        for(int i = 1; i <= 7; i++) {//在table的另外一条链表上添加了 7个B对象
            hashSet.add(new B(i));//
        }



    }
}

class B {
    private int n;

    public B(int n) {
        this.n = n;
    }
    @Override
    public int hashCode() {
        return 200;
    }
}

class A {
    private int n;

    public A(int n) {
        this.n = n;
    }
    @Override
    public int hashCode() {
        return 100;
    }
}
```


对于下面这段代码，首先Hashmap会扩容到16，一直插入元素的时候，会形成一条链表，因为它们的hash值相同。当链表长度等于8的时候，因为数组长度没有达到64，所以不会转化为红黑树，会执行扩容，现在数组的长度是32，接着插入元素的时候，链表的长度又达到了8个还是会继续扩容，阔刀64之后，转化成红黑树
```java
  for(int i = 1; i <= 12; i++) {
            hashSet.add(new A(i));//
       }
```
 
扩容之后，原来的元素会移动位置的，扩容之后，再插入的元素的计算hash的n就又改变了，所以不会挂载在同一根链表上面了
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/99bba3ae6719805d66b6791895afd922.png)

问题：假设元素达到12个就会扩容嘛，那么这个12是指的是table表的空间还是说要加上链表上面的节点呢？

![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/9bdf447854057cb75cb555242e3d1762.png)

我们来看源码
```java
 ++modCount;
        if (++size > threshold)
            resize();
```


加入一个元素的时候，不管是加载table表的某一个位置还是说table表的某一条链表上，都会执行size++

验证

就是下面这段代码，先加的7个A在一条链表上面，那么，我们在加入B的时候，加到5个的时候，链表就会扩容了，A B的hashcode不一样是为了把它们放到不同的链表上面。
```java
 for(int i = 1; i <= 7; i++) {//在table的某一条链表上添加了 7个A对象
            hashSet.add(new A(i));//
        }

        for(int i = 1; i <= 7; i++)   {//在table的另外一条链表上添加了 7个B对象
            hashSet.add(new B(i));//
        }
```


## 2.5 课堂练习

### 2.5.1 

定义一个Employee类,该类包含:private成员属性name.age
1.创建3个Employee对象放入HashSet中
2.当name和age的值相同时,认为是相同员工,不能添加到HashSet集合中

![](image/Pasted%20image%2020230430210144.png)

```java
package com.hspedu.set_;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Objects;
import java.util.Set;
韩顺平循序渐进学Java 零基础
第656页
/**
 * @author 韩顺平
 * @version 1.0
 */
@SuppressWarnings({
    "all"
})
public class HashSetExercise {
    public static void main(String[] args) {
        /**
        定义一个Employee 类，该类包含：private 成员属性name,age 要求:
        创建3 个Employee 对象放入HashSet 中
        当name 和age 的值相同时，认为是相同员工, 不能添加到HashSet 集合中
        */
        HashSet hashSet = new HashSet();
        hashSet.add(new Employee("milan", 18)); //ok
        hashSet.add(new Employee("smith", 28)); //ok
        hashSet.add(new Employee("milan", 18)); //加入不成功.
        //回答,加入了几个? 3 个
        System.out.println("hashSet=" + hashSet);
    }
}
//创建Employee
韩顺平循序渐进学Java 零基础
第657页
class Employee {
    private String name;
    private int age;
    public Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    @Override
    public String toString() {
        return "Employee{" +
            "name='" + name + '\'' +
            ", age=" + age +
            韩顺平循序渐进学Java 零基础
        第658页
            '}';
    }
    public void setAge(int age) {
        this.age = age;
    }
    //如果name 和age 值相同，则返回相同的hash 值
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Employee employee = (Employee) o;
        return age == employee.age &&
            Objects.equals(name, employee.name);
    }
    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}
```


### 2.5.2 HasHSet思考题

定义一个Employee类,该类包含:private成员属性name,sal,birthday(MyDate类型),其中 birthday 为 MyDate类型(属性包括:year, month, day)，要求:
1.创建3个Employee 放入HashSet中
2.当name和birthday的值相同时，认为是相同员工,不能添加到HashSet集合中


```java
package hspCollection.set_;

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

/**
 * Created by 此生辽阔 on 2021/7/22 10:56
 */
public class test1 {
    public static void main(String[] args) {
        Set<Employee>set=new HashSet<>();
        set.add(new Employee("张三",25,new MyDate(1996,7,25)));
        set.add(new Employee("张三",25,new MyDate(1996,8,25)));
        set.add(new Employee("张三",25,new MyDate(1996,7,25)));
        System.out.println(set);
    }
}
class Employee{
    private String name;
    private int age;
    private MyDate date;


    public Employee(String name, int age, MyDate date) {
        this.name = name;
        this.age = age;
        this.date = date;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Employee employee = (Employee) o;
        return date.equals(employee.date) &&
                Objects.equals(name, employee.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name,date);
    }

    @Override
    public String toString() {
        return "Employee{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", date=" + date +
                '}';
    }
}

class MyDate{
    private int year;
    private int month;
    private int day;

    public MyDate(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }
    @Override
    public boolean equals(Object o)
    {
        if(this==o) return true;//地址相同，是两个相同的对象

        if(o == null ||o.getClass()!=this.getClass()) return false;//不是同一类，返回false
        MyDate date=(MyDate) o;
        return  (year==date.year&&month==date.month&&day==date.day) ;
    }
    @Override
    public int hashCode()
    {
        return Objects.hash(year, month,day);
    }

    @Override
    public String toString() {
        return "MyDate{" +
                "year=" + year +
                ", month=" + month +
                ", day=" + day +
                '}';
    }
}


```

equals和hashCode示例2:重写2次
```java
package com.SetExercise;

import org.junit.Test;

import java.util.Date;
import java.util.HashSet;
import java.util.Objects;

/**
 * @author 心向阳光的天域
 * @date 2022/10/7 15:19
 */
public class Employee02 {
    @Test
    public void getPerson() {
        HashSet hashSet = new HashSet();
        hashSet.add(new Employ("小明", 10000.88d, new MyDate("1996", "01", "01")));
        // 姓名一样，出生年份不同
        hashSet.add(new Employ("小明", 10001.88d, new MyDate("1997", "01", "01")));
        // 出生年份和工资不同
        hashSet.add(new Employ("小明", 10001.88d, new MyDate("1998", "01", "01")));
        // 工资和第一个比不同(按照规则，这个应该不展示)
        hashSet.add(new Employ("小明", 10002.88d, new MyDate("1996", "01", "01")));

        // 重写了toString()方法，这里可以遍历一下，看看值
        System.out.println("size:" + hashSet.size());
        for (Object o : hashSet) {
            System.out.println(o);
        }
    }
}

class Employ {
    private String name;
    private double sal;
    private MyDate birthday;

    public Employ(String name, double sal, MyDate birthday) {
        this.name = name;
        this.sal = sal;
        this.birthday = birthday;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Employ employ = (Employ) o;
        return Objects.equals(name, employ.name) && Objects.equals(birthday, employ.birthday);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, birthday);
    }

    @Override
    public String toString() {
        return "Employ{" +
                "name='" + name + '\'' +
                ", sal=" + sal +
                ", birthday=" + birthday +
                '}';
    }
}

class MyDate {
    String year;
    String month;
    String day;

    public MyDate(String year, String month, String day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        MyDate myDate = (MyDate) o;
        return Objects.equals(year, myDate.year) && Objects.equals(month, myDate.month) && Objects.equals(day, myDate.day);
    }

    @Override
    public int hashCode() {
        return Objects.hash(year, month, day);
    }

    @Override
    public String toString() {
        return "MyDate{" +
                "year='" + year + '\'' +
                ", month='" + month + '\'' +
                ", day='" + day + '\'' +
                '}';
    }
}

```

equals和hashCode示例2:重写1次
```java
package com.SetExercise;

import org.junit.Test;

import java.util.Date;
import java.util.HashSet;
import java.util.Objects;

/**
 * @author 心向阳光的天域
 * @date 2022/10/7 15:19
 */
public class Employee03 {
    @Test
    public void getPerson() {
        HashSet hashSet = new HashSet();
        hashSet.add(new Employ("小明", 10000.88d, new MyDate("1996", "01", "01")));
        hashSet.add(new Employ("小明", 10001.88d, new MyDate("1997", "01", "01")));
        hashSet.add(new Employ("小明", 10001.88d, new MyDate("1998", "01", "01")));
        // 按照重复数据去重
        hashSet.add(new Employ("小明", 10002.88d, new MyDate("1996", "01", "01")));

        System.out.println("size:" + hashSet.size());
        for (Object o : hashSet) {
            System.out.println(o);
        }
    }
}

class Employ02 {
    private String name;
    private double sal;
    private MyDate02 birthday;

    public Employ02(String name, double sal, MyDate02 birthday) {
        this.name = name;
        this.sal = sal;
        this.birthday = birthday;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Employ02 employ = (Employ02) o;
        return Objects.equals(name, employ.name)
                // 这里直接重写一次equals方法即可
                && Objects.equals(birthday.getYear(), employ.birthday.getYear())
                && Objects.equals(birthday.getMonth(), employ.birthday.getMonth())
                && Objects.equals(birthday.getDay(), employ.birthday.getDay());
    }

    @Override
    public int hashCode() {
        // 这里直接重写一次hashCode方法即可
        return Objects.hash(name, birthday.year, birthday.month, birthday.day);
    }

    @Override
    public String toString() {
        return "Employ{" +
                "name='" + name + '\'' +
                ", sal=" + sal +
                ", birthday=" + birthday +
                '}';
    }
}

class MyDate02 {
    String year;
    String month;
    String day;

    public MyDate02(String year, String month, String day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }

    public String getYear() {
        return year;
    }

    public void setYear(String year) {
        this.year = year;
    }

    public String getMonth() {
        return month;
    }

    public void setMonth(String month) {
        this.month = month;
    }

    public String getDay() {
        return day;
    }

    public void setDay(String day) {
        this.day = day;
    }

    @Override
    public String toString() {
        return "MyDate{" +
                "year='" + year + '\'' +
                ", month='" + month + '\'' +
                ", day='" + day + '\'' +
                '}';
    }
}

```


# 3 LinkedHashSet


## 3.1 LinkedHashSet的全面说明
(1)LinkedHashSet是HashSet的子类
(2)LinkedHashSet底层是一个LinkedHashMap，底层维护了一个数组+双向链表
(3)LinkedHashSet根据元素的hashCode值来决定元素的存储位置，同时使用链表维护元素的次序图(图)，这使得元素看起来是以插入顺序保存的。
(4)LinkedHashSet不允许添加重复元素

## 3.2 底层机制 
![在这里插入图片描述](https://img-blog.csdnimg.cn/eb29610b5e7a478e8a4be35322b6c703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pbmdtZW5nc2h1eGlhd28=,size_16,color_FFFFFF,t_70)

说明:
1. 在LinkedHashSet中维护一个hash表和双向链表(LinkedHashSet 有head和tail)
2. 每一个结点有before和after属性，这样可以形成双向链表
3. 在添加一个元素时，先求hash值，再求索引，确定该元素在table的位置，然后将添加的元素加入到双向链表(如果已经存在，不添加[原则和hashset一样])
    tail.next = newElement
    newElement.pre = tail
    tail = newElement;
4. 这样的话，我们遍历LinkedHashSet 也能确保插入顺序和遍历顺序一致


```java
package com.hspedu.set_;

import java.util.LinkedHashSet;
import java.util.Set;

/**
 * @author 韩顺平
 * @version 1.0
 */
@SuppressWarnings({"all"})
public class LinkedHashSetSource {
    public static void main(String[] args) {
        //分析一下LinkedHashSet的底层机制
        Set set = new LinkedHashSet();
        set.add(new String("AA"));
        set.add(456);
        set.add(456);
        set.add(new Customer("刘", 1001));
        set.add(123);
        set.add("HSP");

        System.out.println("set=" + set);
        //老韩解读
        //1. LinkedHashSet 加入顺序和取出元素/数据的顺序一致
        //2. LinkedHashSet 底层维护的是一个LinkedHashMap(是HashMap的子类)
        //3. LinkedHashSet 底层结构 (数组table+双向链表)
        //4. 添加第一次时，直接将 数组table 扩容到 16 ,存放的结点类型是 LinkedHashMap$Entry
        //5. 数组是 HashMap$Node[] 存放的元素/数据是 LinkedHashMap$Entry类型
        /*
                //继承关系是在内部类完成.
                static class Entry<K,V> extends HashMap.Node<K,V> {
                    Entry<K,V> before, after;
                    Entry(int hash, K key, V value, Node<K,V> next) {
                        super(hash, key, value, next);
                    }
                }

         */

    }
}
class Customer {
    private String name;
    private int no;

    public Customer(String name, int no) {
        this.name = name;
        this.no = no;
    }
}


```

## 3.3 LinkedHashSet源码分析

LinkedHashSet底层是LinkedHashMap，数组+双向链表
LinkedHashMaps是HashMap的子类
hashMap的table存放的是Node,而LinkedHashMap的table存放的是Entry

```java
public class LinkedHashSet<E>
    extends HashSet<E>
    implements Set<E>, Cloneable, java.io.Serializable {


public class LinkedHashMap<K,V>
    extends HashMap<K,V>
    implements Map<K,V>


static class Entry<K,V> extends HashMap.Node<K,V> {
        Entry<K,V> before, after;
        Entry(int hash, K key, V value, Node<K,V> next) {
            super(hash, key, value, next);
        }
    }

```

## 3.4 练习题 LinkedHashSetExercise.java

![](image/Pasted%20image%2020230430214854.png)


```java
package com.hspedu.set_;
import java.util.LinkedHashSet;
import java.util.Objects;
/**
韩顺平循序渐进学Java 零基础
第661页
* @author 韩顺平
* @version 1.0
*/
@SuppressWarnings({
    "all"
})
public class LinkedHashSetExercise {
    public static void main(String[] args) {
        LinkedHashSet linkedHashSet = new LinkedHashSet();
        linkedHashSet.add(new Car("奥拓", 1000)); //OK
        linkedHashSet.add(new Car("奥迪", 300000)); //OK
        linkedHashSet.add(new Car("法拉利", 10000000)); //OK
        linkedHashSet.add(new Car("奥迪", 300000)); //加入不了
        linkedHashSet.add(new Car("保时捷", 70000000)); //OK
        linkedHashSet.add(new Car("奥迪", 300000)); //加入不了
        System.out.println("linkedHashSet=" + linkedHashSet);
    }
}
/**
 * Car 类(属性:name,price)， 如果name 和price 一样，
 * 则认为是相同元素，就不能添加。5min
 */
class Car {
    韩顺平循序渐进学Java 零基础
    第662页
    private String name;
    private double price;
    public Car(String name, double price) {
        this.name = name;
        this.price = price;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public double getPrice() {
        return price;
    }
    public void setPrice(double price) {
        this.price = price;
    }
    @Override
    public String toString() {
        韩顺平循序渐进学Java 零基础
        第663页
        return "\nCar{" +
            "name='" + name + '\'' +
            ", price=" + price +
            '}';
    }
    //重写equals 方法和hashCode
    //当name 和price 相同时， 就返回相同的hashCode 值, equals 返回t
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Car car = (Car) o;
        return Double.compare(car.price, price) == 0 &&
            Objects.equals(name, car.name);
    }
    @Override
    public int hashCode() {
        return Objects.hash(name, price);
    }
}
```


# 4 TreeSet
![在这里插入图片描述](https://img-blog.csdnimg.cn/229a648ee0c84af092f096b2554b288d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pbmdtZW5nc2h1eGlhd28=,size_16,color_FFFFFF,t_70)

1 
TreeSet实现了Set接口，与HashSet最大的区别是可以排序

![在这里插入图片描述](https://img-blog.csdnimg.cn/b1f57fcf78e4454db5cbb3f31f19ad0e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pbmdtZW5nc2h1eGlhd28=,size_16,color_FFFFFF,t_70)

2 
在向TreeSet添加元素时，如果不指定比较器，那么会将Key强制转化为比较器比较，因此key必须实现Comparable接口，不然无法添加元素

```java
public class treesettEST {
    public static void main(String[] args) {
        TreeSet<Object> treeSet = new TreeSet<>();
        treeSet.add(new person(2));
        treeSet.add(new person(3));
    }
}
class person{
    private int i;

    public person(int i) {
        this.i = i;
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/8a43f276dd6b4889b30f7aa46fbb0c54.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pbmdtZW5nc2h1eGlhd28=,size_16,color_FFFFFF,t_70)



3 
TreeSet底层是TreeMap,TreeMap有一个属性是comparator

```java
package com.hspedu.set_;

import java.util.Comparator;
import java.util.TreeSet;

/**
 * @author 韩顺平
 * @version 1.0
 */
@SuppressWarnings({"all"})
public class TreeSet_ {
    public static void main(String[] args) {

        //老韩解读
        //1. 当我们使用无参构造器，创建TreeSet时，仍然是无序的
        //2. 老师希望添加的元素，按照字符串大小来排序
        //3. 使用TreeSet 提供的一个构造器，可以传入一个比较器(匿名内部类)
        //   并指定排序规则
        //4. 简单看看源码
        //老韩解读
        /*
        1. 构造器把传入的比较器对象，赋给了 TreeSet的底层的 TreeMap的属性this.comparator

         public TreeMap(Comparator<? super K> comparator) {
                this.comparator = comparator;
            }
         2. 在 调用 treeSet.add("tom"), 在底层会执行到

             if (cpr != null) {//cpr 就是我们的匿名内部类(对象)
                do {
                    parent = t;
                    //动态绑定到我们的匿名内部类(对象)compare
                    cmp = cpr.compare(key, t.key);
                    if (cmp < 0)
                        t = t.left;
                    else if (cmp > 0)
                        t = t.right;
                    else //如果相等，即返回0,这个Key就没有加入
                        return t.setValue(value);
                } while (t != null);
            }
         */
//        TreeSet treeSet = new TreeSet();
        TreeSet treeSet = new TreeSet(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                //下面 调用String的 compareTo方法进行字符串大小比较
                //如果老韩要求加入的元素，按照长度大小排序
                //return ((String) o2).compareTo((String) o1);
                return ((String) o1).length() - ((String) o2).length();
            }
        });
        //添加数据.
        treeSet.add("jack");
        treeSet.add("tom");//3
        treeSet.add("sp");
        treeSet.add("a");
        treeSet.add("abc");//3
        System.out.println("treeSet=" + treeSet);
    }
}

```


```java
package com.SetExercise;

import org.junit.Test;

import java.util.Comparator;
import java.util.TreeSet;

/**
 * @author wty
 * @date 2022/10/10 10:20
 */

public class TreeSetExercise {
    @Test
    @SuppressWarnings({"all"})
    public void getTreeSet() {
        // 当使用无参构造器创建TreeSet的时候是无序的
        TreeSet treeSet = new TreeSet();
        // 添加数据
        treeSet.add("Derrick");
        treeSet.add("Rose");
        treeSet.add("Jam");
        treeSet.add("Timmy");
        treeSet.add("Tom");

        System.out.println(treeSet);


        System.out.println("---字符串按照首字母顺序比较---");
        // 添加的元素按照字符串大小来排序
        // 可以传入一个比较器(匿名内部类)，并指定规则
        TreeSet treeSet1 = new TreeSet(new Comparator() {
            @Override
            public int compare(Object o, Object t1) {
                return ((String) o).compareTo((String) t1);
            }
        });
        treeSet1.add("Derrick");
        treeSet1.add("Rose");
        treeSet1.add("Jam");
        treeSet1.add("Timmy");
        treeSet1.add("Tom");

        System.out.println(treeSet1);
        // 源码解读
        /**
         *     public TreeMap(Comparator<? super K> var1) {
         *         this.comparator = var1; 把new Comparator() 给到TreeMap的comparator属性
         *     }
         */

        System.out.println("---字符串长度大小比较---");
        TreeSet treeSet2 = new TreeSet(new Comparator() {
            @Override
            public int compare(Object o, Object t1) {
                String str_a = (String) o;
                String str_t1 = (String) t1;
                int a = ((String) o).length();
                int b = ((String) t1).length();
                int result = a - b;
                return result = result == 0 ? str_a.compareTo(str_t1) : result;
            }
        });
        treeSet2.add("Derrick");
        treeSet2.add("Amy");
        treeSet2.add("Rose");
        treeSet2.add("Jam"); // 相同长度加不进去
        treeSet2.add("Timmy");
        treeSet2.add("Tom");// 相同长度加不进去


        System.out.println(treeSet2);


    }
}

```