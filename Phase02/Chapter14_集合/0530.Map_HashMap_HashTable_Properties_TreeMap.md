
# 1 Map_HashMap_Hashtable_TreeMap

## 1.1 Interface Map<K, V> 实现类的特点


![在这里插入图片描述](https://img-blog.csdnimg.cn/08e2c278ba194559b55709add998a498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pbmdtZW5nc2h1eGlhd28=,size_16,color_FFFFFF,t_70)

(1)Map与Collection并列存在，用于保存具有映射关系的数据Key-Value(双列元素)
(2)Map中的key和value可以是任何引用类型的数据，会封装到HashMap$Node对象中
(3)Map中的key不允许重复，原因和HashSet一样，前面分析过源码。
(4)Map中的value可以重复
(5)Map的key可以为null，value也可以为null，注意key为null，只能有一个，value为null可以多个
(6)常用String类作为Map的key
(7)key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value
(8)Map存放数据的key-value示意图，一对key-value 是放在一个Node中的，又因为Node实现了Entry接口，有些书上也说一对key-value就是一个Entry(如图)



### 1.1.1 例子

entrySet()获取entrySet,entrySet是一个Set<Entry<key,value>接口，里面存放的是Entry对象，Entry对象里面存放的是key的引用和value的引用
```java

package com.hspedu.map_;
import java.util.HashMap;
import java.util.Map;
/**
 * @author 韩顺平
 * @version 1.0
 */
@SuppressWarnings({
    "all"
})
public class Map_ {
    public static void main(String[] args) {
        //老韩解读Map 接口实现类的特点, 使用实现类HashMap
        //1. Map 与Collection 并列存在。用于保存具有映射关系的数据:Key-Value(双列元素)
        //2. Map 中的key 和value 可以是任何引用类型的数据，会封装到HashMap$Node 对象中
        //3. Map 中的key 不允许重复，原因和HashSet 一样，前面分析过源码.
        //4. Map 中的value 可以重复
        //5. Map 的key 可以为null, value 也可以为null ，注意key 为null,
        韩顺平循序渐进学Java 零基础
        第665页
        // 只能有一个，value 为null ,可以多个
        //6. 常用String 类作为Map 的key
        //7. key 和value 之间存在单向一对一关系，即通过指定的key 总能找到对应的value
        Map map = new HashMap();
        map.put("no1", "韩顺平"); //k-v
        map.put("no2", "张无忌"); //k-v
        map.put("no1", "张三丰"); //当有相同的k , 就等价于替换.
        map.put("no3", "张三丰"); //k-v
        map.put(null, null); //k-v
        map.put(null, "abc"); //等价替换
        map.put("no4", null); //k-v
        map.put("no5", null); //k-v
        map.put(1, "赵敏"); //k-v
        map.put(new Object(), "金毛狮王"); //k-v
        // 通过get 方法，传入key ,会返回对应的value
        System.out.println(map.get("no2")); //张无忌
        System.out.println("map=" + map);
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/dd2e8dbd9baa46b7ad95062779feddf2.png)  
虽然null是第二个打印出来的，但是从debug可以看出，key为null时是存在索引为0的位置的  
![在这里插入图片描述](https://img-blog.csdnimg.cn/40b224d1a4504dc19734b0ea0a68b077.png)

![](image/Pasted%20image%2020230430215346.png)


## 1.2 根据key获取value的过程

首先会获取key的hash值，根据这个hash值获取key所在的索引，然后根据这个索引值找到该索引下的第一个节点，判断该节点是否是我们要找的节点，如果是，就返回该节点，如果不是，再判断该节点处是否形成了红黑树，如果是，就根据红黑树的查找方法，如果不是，就再判断是否形成链表，是就遍历链表的节点，依次匹配，如果最终没有找到匹配的节点，就返回null


```java
 public V get(Object key) {
        Node<K,V> e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    }

```


## 1.3 Map接口常用方法

(1)put:添加  
(2)remove:根据键删除映射关系  
(3)get：根据键获取值  
(4)size：获取元素个数  
(5)isEmpty:判断个数是否为0  
(6)clear:清除  
(7)containsKey：查找键是否存在


```java

package com.hspedu.map_;
import java.util.HashMap;
import java.util.Map;
/**
 * @author 韩顺平
 * @version 1.0
 */
@SuppressWarnings({
    "all"
})
public class MapMethod {
    public static void main(String[] args) {
        //演示map 接口常用方法
        Map map = new HashMap();
        map.put("邓超", new Book("", 100)); //OK
        韩顺平循序渐进学Java 零基础
        第667页
        map.put("邓超", "孙俪"); //替换-> 一会分析源码
        map.put("王宝强", "马蓉"); //OK
        map.put("宋喆", "马蓉"); //OK
        map.put("刘令博", null); //OK
        map.put(null, "刘亦菲"); //OK
        map.put("鹿晗", "关晓彤"); //OK
        map.put("hsp", "hsp 的老婆");
        System.out.println("map=" + map);
        // remove:根据键删除映射关系
        map.remove(null);
        System.out.println("map=" + map);
        // get：根据键获取值
        Object val = map.get("鹿晗");
        System.out.println("val=" + val);
        // size:获取元素个数
        System.out.println("k-v=" + map.size());
        // isEmpty:判断个数是否为0
        System.out.println(map.isEmpty()); //F
        // clear:清除k-v
        //map.clear();
        System.out.println("map=" + map);
        // containsKey:查找键是否存在
        System.out.println("结果=" + map.containsKey("hsp")); //T
        韩顺平循序渐进学Java 零基础
        第668页
    }
}
class Book {
    private String name;
    private int num;
    public Book(String name, int num) {
        this.name = name;
        this.num = num;
    }
}
```

## 1.4 Map接口遍历方法

Map遍历的示意图(比List，和Set复杂一点，但是基本原理一样)  
(1)containsKey：查找键是否存在  
(2)keySet：获取所有的键  
(3)entrySet：获取所有关系  
(4)values：获取所有的值

```java

package com.hspedu.map_;
import java.util.*;
/**
 * @author 韩顺平
 * @version 1.0
 */
@SuppressWarnings({
    "all"
})
public class MapFor {
    public static void main(String[] args) {
        Map map = new HashMap();
        map.put("邓超", "孙俪");
        map.put("王宝强", "马蓉");
        map.put("宋喆", "马蓉");
        map.put("刘令博", null);
        map.put(null, "刘亦菲");
        map.put("鹿晗", "关晓彤");
        //第一组: 先取出所有的Key , 通过Key 取出对应的Value
        Set keyset = map.keySet();
        韩顺平循序渐进学Java 零基础
        第670页
        //(1) 增强for
        System.out.println("-----第一种方式-------");
        for (Object key: keyset) {
            System.out.println(key + "-" + map.get(key));
        }
        //(2) 迭代器
        System.out.println("----第二种方式--------");
        Iterator iterator = keyset.iterator();
        while (iterator.hasNext()) {
            Object key = iterator.next();
            System.out.println(key + "-" + map.get(key));
        }
        //第二组: 把所有的values 取出
        Collection values = map.values();
        //这里可以使用所有的Collections 使用的遍历方法
        //(1) 增强for
        System.out.println("---取出所有的value 增强for----");
        for (Object value: values) {
            System.out.println(value);
        }
        //(2) 迭代器
        System.out.println("---取出所有的value 迭代器----");
        Iterator iterator2 = values.iterator();
        while (iterator2.hasNext()) {
            Object value = iterator2.next();
            韩顺平循序渐进学Java 零基础
            第671页
            System.out.println(value);
        }
        //第三组: 通过EntrySet 来获取k-v
        Set entrySet = map.entrySet(); // EntrySet<Map.Entry<K,V>>
        //(1) 增强for
        System.out.println("----使用EntrySet 的for 增强(第3 种)----");
        for (Object entry: entrySet) {
            //将entry 转成Map.Entry
            Map.Entry m = (Map.Entry) entry;
            System.out.println(m.getKey() + "-" + m.getValue());
        }
        //(2) 迭代器
        System.out.println("----使用EntrySet 的迭代器(第4 种)----");
        Iterator iterator3 = entrySet.iterator();
        while (iterator3.hasNext()) {
            Object entry = iterator3.next();
            //System.out.println(next.getClass());//HashMap$Node -实现-> Map.Entry (getKey,getValue)
            //向下转型Map.Entry
            Map.Entry m = (Map.Entry) entry;
            System.out.println(m.getKey() + "-" + m.getValue());
        }
    }
    韩顺平循序渐进学Java 零基础
    第672页
}
```


## 1.5 Map接口案例

MapExercise.java
使用HashMap添加3个员工对象,要求键:员工id
值:员工对象
并遍历显示工资>18000的员工(遍历方式最少两种)员工类:姓名、工资、员工id

```java
package com.hspedu.map_;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
/**
 * @author 韩顺平
 * @version 1.0
 */
@SuppressWarnings({
    "all"
})
public class MapExercise {
    public static void main(String[] args) {
        //完成代码
        Map hashMap = new HashMap();
        //添加对象
        韩顺平循序渐进学Java 零基础
        第673页
        hashMap.put(1, new Emp("jack", 300000, 1));
        hashMap.put(2, new Emp("tom", 21000, 2));
        hashMap.put(3, new Emp("milan", 12000, 3));
        //遍历2 种方式
        //并遍历显示工资>18000 的员工(遍历方式最少两种)
        //1. 使用keySet -> 增强for
        Set keySet = hashMap.keySet();
        System.out.println("====第一种遍历方式====");
        for (Object key: keySet) {
            //先获取value
            Emp emp = (Emp) hashMap.get(key);
            if (emp.getSal() > 18000) {
                System.out.println(emp);
            }
        }
        //2. 使用EntrySet -> 迭代器
        // 体现比较难的知识点
        // 慢慢品，越品越有味道.
        Set entrySet = hashMap.entrySet();
        System.out.println("======迭代器======");
        Iterator iterator = entrySet.iterator();
        while (iterator.hasNext()) {
            Map.Entry entry = (Map.Entry) iterator.next();
            韩顺平循序渐进学Java 零基础
            第674页
            //通过entry 取得key 和value
            Emp emp = (Emp) entry.getValue();
            if (emp.getSal() > 18000) {
                System.out.println(emp);
            }
        }
    }
}
/**
 * 使用HashMap 添加3 个员工对象，要求
 * 键：员工id
 * 值：员工对象
 *
 * 并遍历显示工资>18000 的员工(遍历方式最少两种)
 * 员工类：姓名、工资、员工id
 */
class Emp {
    private String name;
    private double sal;
    private int id;
    public Emp(String name, double sal, int id) {
        this.name = name;
        this.sal = sal;
        this.id = id;
        韩顺平循序渐进学Java 零基础
        第675页
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public double getSal() {
        return sal;
    }
    public void setSal(double sal) {
        this.sal = sal;
    }
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    韩顺平循序渐进学Java 零基础
    第676页
    @Override
    public String toString() {
        return "Emp{" +
            "name='" + name + '\'' +
            ", sal=" + sal +
            ", id=" + id +
            '}';
    }
}

```

# 2 HashMap

## 2.1 总结
![在这里插入图片描述](https://img-blog.csdnimg.cn/ac041134435345239424da6c0893355f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pbmdtZW5nc2h1eGlhd28=,size_16,color_FFFFFF,t_70)

Map接口的常用实现类:HashMap、Hashtable和Properties
HashMap是Map接口使用频率最高的实现类
HashMap是以key-value 对的方式来存储数据(HashMap$Node类型)
key不能重复，但是值可以重复，允许使用null值和null键(null键只能有1个)
如果添加相同的key，则会覆盖原来的key-val，等同于修改(key不会替换，val会替换)
与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的。
HashMap没有实现同步，因此是线程不安全的,方法没有做同步互斥的操作，没有synchronized




## 2.2 低层机制和源码剖析

![](image/Pasted%20image%2020230430215944.png)

(1)HashMap底层维护了Node类型的数组table，默认为null
(2)当创建对象时，将加载因子(loadFactor)初始化为0.75
(3)当添加key-value时，通过key的哈希值得到在table的索引。然后判断该索引处是否有元素，如果没有元素，则直接添加。如果该处索引有元素，则继续判断该元素的key是否和准备加入的key相等，如果相等，则直接替换成新的val，如果不相等，需要判断是树结构还是链表结构，做出相应的处理。如果添加时发现容量不够，则需要扩容。
(4)第1次添加，则需要扩容table容量为16，临界值(threshold)为12
(5)以后再扩容，则需要扩容table容量为原来的2倍，临界值为原来的2倍，即24，以此类推。
(6)在Java8中，如果一条链表的元素个数超过了TREEIFY_THRESHOLD(默认是8)，并且table的大小>= MIN_TREEIFY_CAPACITY(默认64)，就会进行树化(红黑树)

```java
package com.hspedu.map_;
import java.util.HashMap;
/**
* @author 韩顺平
* @version 1.0
韩顺平循序渐进学Java 零基础
第678页
*/
@SuppressWarnings({
    "all"
})
public class HashMapSource1 {
    public static void main(String[] args) {
        HashMap map = new HashMap();
        map.put("java", 10); //ok
        map.put("php", 10); //ok
        map.put("java", 20); //替换value
        System.out.println("map=" + map); //
        /*老韩解读HashMap 的源码+图解
        1. 执行构造器new HashMap()
        初始化加载因子loadfactor = 0.75
        HashMap$Node[] table = null
        2. 执行put 调用hash 方法，计算key 的hash 值(h = key.hashCode()) ^ (h >>> 16)
        public V put(K key, V value) {//K = "java" value = 10
        return putVal(hash(key), key, value, false, true);
        }
        3. 执行putVal
        final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
        boolean evict) {
        Node<K,V>[] tab; Node<K,V> p; int n, i;//辅助变量
        //如果底层的table 数组为null, 或者length =0 , 就扩容到16
        if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
        韩顺平循序渐进学Java 零基础
        第679页
        //取出hash 值对应的table 的索引位置的Node, 如果为null, 就直接把加入的k-v
        //, 创建成一个Node ,加入该位置即可
        if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
        else {
        Node<K,V> e; K k;//辅助变量
        // 如果table 的索引位置的key 的hash 相同和新的key 的hash 值相同，
        // 并满足(table 现有的结点的key 和准备添加的key 是同一个对象|| equals 返回真)
        // 就认为不能加入新的k-v
        if (p.hash == hash &&
        ((k = p.key) == key || (key != null && key.equals(k))))
        e = p;
        else if (p instanceof TreeNode)//如果当前的table 的已有的Node 是红黑树，就按照红黑树的方式处
        理
        e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        else {
        //如果找到的结点，后面是链表，就循环比较
        for (int binCount = 0; ; ++binCount) {//死循环
        if ((e = p.next) == null) {//如果整个链表，没有和他相同,就加到该链表的最后
        p.next = newNode(hash, key, value, null);
        //加入后，判断当前链表的个数，是否已经到8 个，到8 个，后
        //就调用treeifyBin 方法进行红黑树的转换
        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
        treeifyBin(tab, hash);
        break;
        }
        韩顺平循序渐进学Java 零基础
        第680页
        if (e.hash == hash && //如果在循环比较过程中，发现有相同,就break,就只是替换value
        ((k = e.key) == key || (key != null && key.equals(k))))
        break;
        p = e;
        }
        }
        if (e != null) { // existing mapping for key
        V oldValue = e.value;
        if (!onlyIfAbsent || oldValue == null)
        e.value = value; //替换，key 对应value
        afterNodeAccess(e);
        return oldValue;
        }
        }
        ++modCount;//每增加一个Node ,就size++
        if (++size > threshold[12-24-48])//如size > 临界值，就扩容
        resize();
        afterNodeInsertion(evict);
        return null;
        }
        5. 关于树化(转成红黑树)
        //如果table 为null ,或者大小还没有到64，暂时不树化，而是进行扩容.
        //否则才会真正的树化-> 剪枝
        final void treeifyBin(Node<K,V>[] tab, int hash) {
        int n, index; Node<K,V> e;
        韩顺平循序渐进学Java 零基础
        第681页
        if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)
        resize();
        }
        */
    }
}
```

### 2.2.1 HashMap树化


```java
public class HashMapSource2 {
    public static void main(String[] args) {


        HashMap hashMap = new HashMap();
        for(int i = 1; i <= 12; i++) {
            hashMap.put(new A(i), "hello");
        }

        hashMap.put("aaa", "bbb");

        System.out.println("hashMap=" + hashMap);//12个 k-v

        //布置一个任务，自己设计代码去验证，table 的扩容
        //0 -> 16(12) -> 32(24) -> 64(64*0.75=48)-> 128 (96) ->
        //自己设计程序，验证-》 增强自己阅读源码能力. 看别人代码.
    }
}

class A  {
    private int num;

    public A(int num) {
        this.num = num;
    }

    //所有的A对象的hashCode都是100
    @Override
    public int hashCode() {
        return 100;
    }

    @Override
    public String toString() {
        return "\nA{" +
                "num=" + num +
                '}';
    }
}

```

可以看到现在i已经加到8了，底层的table有7个元素（因为i对应的8还没有执行第8次添加元素）
![在这里插入图片描述](https://img-blog.csdnimg.cn/84592ed7ad554326b3379a2b21be4be5.png)

这是底层的排列情况，一条长度为7的链表  
![在这里插入图片描述](https://img-blog.csdnimg.cn/55ed804d963b4e8387f17747bc941856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pbmdtZW5nc2h1eGlhd28=,size_16,color_FFFFFF,t_70)

现在我们再执行第8次添加

容量是15，链表的长度是8  
![在这里插入图片描述](https://img-blog.csdnimg.cn/00044f0ba5614781aa9a864e6224089e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pbmdtZW5nc2h1eGlhd28=,size_16,color_FFFFFF,t_70)

继续添加

由于链表长度到达了8，在添加第9个节点的时候，判断应该进行转化为红黑树，但是由于table中总的节点数没有达到64，所以只是进行了扩容，没有转化为红黑树，且此时链表的长度为9，
![在这里插入图片描述](https://img-blog.csdnimg.cn/c0ce1734d9e8491badef0c22343d703c.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/a1db90d64b6445ff99db226891322a2a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pbmdtZW5nc2h1eGlhd28=,size_16,color_FFFFFF,t_70)  


继续添加第10个节点，数组容量依然没有达到64（此时是32），所以不会转化成红黑树，将会继续扩容（扩容到64），此时链表长度为10  
![在这里插入图片描述](https://img-blog.csdnimg.cn/08321db14229466b94d3adee5efafb54.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pbmdtZW5nc2h1eGlhd28=,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/addf5dba0ff04e8ebfa3c1f4061f95e7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pbmdtZW5nc2h1eGlhd28=,size_16,color_FFFFFF,t_70)

当添加第11个节点的时候，由于数组容量已经达到了64，所以会转化成红黑树，不再继续扩容
![在这里插入图片描述](https://img-blog.csdnimg.cn/47f575a8e0274fe88b5e2d6b0e31c62f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pbmdtZW5nc2h1eGlhd28=,size_16,color_FFFFFF,t_70)  
![在这里插入图片描述](https://img-blog.csdnimg.cn/2ecda8ce7f9347e88152237442932340.png)

注意扩容后会影响元素的索引位置，因为hash值重新计算了

### 2.2.2 HashMap 扩容

```java
package hspCollection.map;

/**
 * Created by 此生辽阔 on 2021/7/25 10:06
 */
import java.util.HashMap;
import java.util.Objects;
import java.util.Random;
public class HashMapSource2 {
    public static void main(String[] args) {

        Random r=new  Random();
        HashMap hashMap = new HashMap();
        for(int i = 1; i <= 12; i++) {
            hashMap.put(r.nextInt(100), "hello");
        }
        hashMap.put("aaa", "bbb");
        System.out.println("hashMap=" + hashMap);//12个 k-v
    }
}


```

![在这里插入图片描述](https://img-blog.csdnimg.cn/460038645cf04056a2c425d481f246f6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pbmdtZW5nc2h1eGlhd28=,size_16,color_FFFFFF,t_70)  
断点打在 hashMap.put(“aaa”, “bbb”);执行完结果如上图，现在还没有扩容，且节点数量刚好达到12各个，现在执行 hashMap.put(“aaa”, “bbb”);

执行了扩容，且影响了原来元素的位置排列  
![在这里插入图片描述](https://img-blog.csdnimg.cn/d70d45e7168d4a2aac07900d32f3fa32.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pbmdtZW5nc2h1eGlhd28=,size_16,color_FFFFFF,t_70)

# 3 Hashtable

## 3.1 概要
(1)存放的元素是键值对:即K-V
(2)hashtable的键和值都不能为null，否则会抛出NullPointerException
(3)hashTable使用方法基本上和HashMap一样
(4)hashTable是线程安全的(synchronized)，hashMap是线程不安全的


## 3.2 底层结构
实现Map接口

注意:
//1. 底层有数组 Hashtable$Entry[] 初始化大小为 11
//2. 临界值 threshold 8 = 11 * 0.75
//3. 扩容: 按照自己的扩容机制来进行即可.
//4. 执行 方法 addEntry(hash, key, value, index); 添加K-V 封装到Entry
//5. 当 if (count >= threshold) 满足时，就进行扩容
//6. 按照 int newCapacity = (oldCapacity << 1) + 1; 的大小扩容.（2倍加1）

## 3.3 例子

![](image/Pasted%20image%2020230430220713.png)


## 3.4 Hashtable 和HashMap 对比

![在这里插入图片描述](https://img-blog.csdnimg.cn/afee6ead36704de9a55377c6f3760d2a.png)

# 4 Properties

## 4.1 基本介绍

![在这里插入图片描述](https://img-blog.csdnimg.cn/457556db76454c33b9c21a65833c120b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pbmdtZW5nc2h1eGlhd28=,size_16,color_FFFFFF,t_70)

properties是hashtable的子类，所以间接地实现了Map接口

1.  Properties类继承自Hashtable类并且实现了Map接口，也是一种键值对的形式来保存数据。
2. 它的使用特点和Hashtable类似。
3. Properties还可以用于从xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改。
4. 说明:工作后xxx.properties文件通常作为配置文件，这个知识点在IO流举例，有兴趣可先看文章。

配置文件不会显示乱码，统一调整为UTF-8
![](https://img-blog.csdn.net/20171129155059833?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2dsMTI1MTY3MDE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

## 4.2 基本使用

```java
package com.hspedu.map_;
import java.util.Properties;
/**
 * @author 韩顺平
 * @version 1.0
 */
@SuppressWarnings({
    "all"
})
public class Properties_ {
    public static void main(String[] args) {
        //老韩解读
        //1. Properties 继承Hashtable
        //2. 可以通过k-v 存放数据，当然key 和value 不能为null
        //增加
        Properties properties = new Properties();
        //properties.put(null, "abc");//抛出空指针异常
        //properties.put("abc", null); //抛出空指针异常
        properties.put("john", 100); //k-v
        properties.put("lucy", 100);
        properties.put("lic", 100);
        properties.put("lic", 88); //如果有相同的key ， value 被替换
        System.out.println("properties=" + properties);
        韩顺平循序渐进学Java 零基础
        第686页
        //通过k 获取对应值
        System.out.println(properties.get("lic")); //88
        //删除
        properties.remove("lic");
        System.out.println("properties=" + properties);
        //修改
        properties.put("john", "约翰");
        System.out.println("properties=" + properties);
    }
}
```



# 5 TreeMap

```java
package com.hspedu.map_;

import java.util.Comparator;
import java.util.TreeMap;

/**
 * @author 韩顺平
 * @version 1.0
 */
@SuppressWarnings({"all"})
public class TreeMap_ {
    public static void main(String[] args) {

        //使用默认的构造器，创建TreeMap, 是无序的(也没有排序)
        /*
            老韩要求：按照传入的 k(String) 的大小进行排序
         */
//        TreeMap treeMap = new TreeMap();
        TreeMap treeMap = new TreeMap(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                //按照传入的 k(String) 的大小进行排序
                //按照K(String) 的长度大小排序
                //return ((String) o2).compareTo((String) o1);
                return ((String) o2).length() - ((String) o1).length();
            }
        });
        treeMap.put("jack", "杰克");
        treeMap.put("tom", "汤姆");
        treeMap.put("kristina", "克瑞斯提诺");
        treeMap.put("smith", "斯密斯");
        treeMap.put("hsp", "韩顺平");//加入不了

        System.out.println("treemap=" + treeMap);

        /*

            老韩解读源码：
            1. 构造器. 把传入的实现了 Comparator接口的匿名内部类(对象)，传给给TreeMap的comparator
             public TreeMap(Comparator<? super K> comparator) {
                this.comparator = comparator;
            }
            2. 调用put方法
            2.1 第一次添加, 把k-v 封装到 Entry对象，放入root
            Entry<K,V> t = root;
            if (t == null) {
                compare(key, key); // type (and possibly null) check

                root = new Entry<>(key, value, null);
                size = 1;
                modCount++;
                return null;
            }
            2.2 以后添加
            Comparator<? super K> cpr = comparator;
            if (cpr != null) {
                do { //遍历所有的key , 给当前key找到适当位置
                    parent = t;
                    cmp = cpr.compare(key, t.key);//动态绑定到我们的匿名内部类的compare
                    if (cmp < 0)
                        t = t.left;
                    else if (cmp > 0)
                        t = t.right;
                    else  //如果遍历过程中，发现准备添加Key 和当前已有的Key 相等，就不添加
                        return t.setValue(value);
                } while (t != null);
            }
         */

    }
}

```


```java
package com.Map;

import org.junit.Test;

import java.util.Comparator;
import java.util.TreeMap;

/**
 * @author wty
 * @date 2022/10/10 12:33
 */
public class TreeMapExercise {
    @Test
    public void getTreeMap() {
        // 无参数，无序取出
        TreeMap treeMap = new TreeMap();
        treeMap.put("1", "Jack");
        treeMap.put("no2", "Tom");
        treeMap.put("李小璐", "PGONE");
        treeMap.put("smith", "史密斯");

        System.out.println(treeMap);

        // 按照key字符串首字母倒叙排序
        TreeMap treeMap2 = new TreeMap(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                return ((String) o2).compareTo((String) o1);
            }
        });
        System.out.println("按照key字符串首字母倒叙排序");
        treeMap2.put("1", "Jack");
        treeMap2.put("no2", "Tom");
        treeMap2.put("李小璐", "PGONE");
        treeMap2.put("smith", "史密斯");
        treeMap2.put("alice", "漫游记");
        System.out.println(treeMap2);

        // 按照key字符串长度排序，相同长度按首字母倒叙排序
        TreeMap treeMap3 = new TreeMap(new Comparator() {
            @Override
            public int compare(Object o1, Object o2) {
                String str_o1 = (String) o1;
                String str_o2 = (String) o2;

                int a = str_o1.length();
                int b = str_o2.length();

                int result = a == b ? str_o1.compareTo(str_o2) : a - b;

                return result;
            }
        });
        System.out.println("按照key字符串长度排序，相同长度按首字母顺叙排序");
        treeMap3.put("1", "Jack");
        treeMap3.put("no2", "Tom");
        treeMap3.put("李小璐", "PGONE");
        treeMap3.put("smith", "史密斯");
        treeMap3.put("alice", "漫游记");
        treeMap3.put("tonny", "理发师");
        System.out.println(treeMap3);
    }
}

```