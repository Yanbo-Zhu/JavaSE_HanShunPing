异常处理就是当异常发生时，对异常处理的方式


# 1 异常处理方法

try-catch-finally: 程序员在代码块中捕获发生的异常，自行处理

![](https://img-blog.csdnimg.cn/f12db9aeb99b4a87a5357f0f523b5e14.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-v5Y-v54ix54ix55qE5bCP56eD5aS0,size_12,color_FFFFFF,t_70,g_se,x_16)

throws: 将发生的异常抛出，交给调用者来处理，最顶级的处理者是JVM
![](https://img-blog.csdnimg.cn/2e390b9980a54031ab522c26f3f3922e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Y-v5Y-v54ix54ix55qE5bCP56eD5aS0,size_14,color_FFFFFF,t_70,g_se,x_16)



# 2 try-catch方式处理异常
1.简单案例

    int num1 = 10; 
    int num2 = 0; 
    try {
    int res = num1 / num2; 
    } catch (Exception e) { 
    System.out.println(e.getMessage()); }

2.使用细节

细节1.
 1)如果异常发生了，则异常发生后面的代码不会执行，直接进入到catch块
 2)如果异常没有发生，则顺序执行try的代码块，不会进入到catch
 3)如果希望不管是否发生异常，都执行某段代码(比如关闭连接，释放资源等)则使用如下代码- finally

```java
    //ctrl + atl + t快捷键try-catch
     
            //1. 如果异常发生了，则异常发生后面的代码不会执行，直接进入到catch块
            //2. 如果异常没有发生，则顺序执行try的代码块，不会进入到catch
            //3. 如果希望不管是否发生异常，都执行某段代码(比如关闭连接，释放资源等)则使用如下代码- finally
            try {
                String str = "韩顺平";
                int a = Integer.parseInt(str);
                System.out.println("数字：" + a);
            } catch (NumberFormatException e) {
                System.out.println("异常信息=" + e.getMessage());
            } finally {
                System.out.println("finally代码块被执行...");
            }
     
            System.out.println("程序继续...");
```



细节2.
1）如果try代码块有可能有多个异常
2）可以使用多个catch 分别捕获不同的异常，相应处理
3）要求子类异常写在前面，父类异常写在后面
```java
class Person {
	private String name = "jack";
 
	public String getName() {
		return name;
	}
}
 
 
//1.如果try代码块有可能有多个异常
//2.可以使用多个catch 分别捕获不同的异常，相应处理
//3.要求子类异常写在前面，父类异常写在后面
try {
	Person person = new Person();
	//person = null;
	System.out.println(person.getName());//NullPointerException
	int n1 = 10;
	int n2 = 0;
	int res = n1 / n2;//ArithmeticException
} catch (NullPointerException e) {
	System.out.println("空指针异常=" + e.getMessage());
} catch (ArithmeticException e) {
	System.out.println("算术异常=" + e.getMessage());
} catch (Exception e) {
	System.out.println(e.getMessage());
} finally {
}
```


细节3.
```java
/*
可以进行 try-finally 配合使用, 这种用法相当于没有捕获异常，
因此程序会直接崩掉/退出。应用场景，就是执行一段代码，不管是否发生异常，
都必须执行某个业务逻辑
 */
 
try{
	int n1 = 10;
	int n2 = 0;
	System.out.println(n1 / n2);
}finally {
	System.out.println("执行了finally..");
}
System.out.println("程序继续执行..");

}

```


## 2.1 try-catch练习（判断下面代码的输出结果）

练习1.
```java
try {
            String[] names = new String[3];//String[]数组
            if (names[1].equals("tom")) {//NullPointerException
                System.out.println(names[1]);
            } else {
                names[3] = "hspedu";
            }
            return 1;
        } catch (ArrayIndexOutOfBoundsException e) {
            return 2;
        } catch (NullPointerException e) {//捕获
            return 3;
        } finally { //必须执行
            return 4; //返回4
        }
    }
 
    public static void main(String[] args) {
        System.out.println(method()); //4
    }
//第三行出现异常直接跳到catch捕获错误
//执行return 3，但是finally是必须执行的，所以return 4
```


练习2
```java
int i = 1;
try {
	i++; //i = 2
	String[] names = new String[3];
	if (names[1].equals("tom")) {//空指针
		System.out.println(names[1]);
	} else {
		names[3] = "hspedu";
	}
	return 1;
} catch (ArrayIndexOutOfBoundsException e) {
	return 2;
} catch (NullPointerException e) {
	return ++i; //i = 3
} finally {//必须执行
	return ++i; //i = 4
}
}

public static void main(String[] args) {
System.out.println(method());
}
```


练习3.
```java
int i = 1;//i = 1
try {
	i++;// i=2
	String[] names = new String[3];
	if (names[1].equals("tom")) { //空指针
		System.out.println(names[1]);
	} else {
		names[3] = "hspedu";
	}
	return 1;
} catch (ArrayIndexOutOfBoundsException e) {
	return 2;
} catch (NullPointerException e) {
	return ++i;  // i = 3 => 保存临时变量 temp = 3;
} finally {
	++i; //i = 4
	System.out.println("i=" + i);// i = 4
}
}

public static void main(String[] args) {
System.out.println(method());// 3
}
```


练习4.
如果用户输入的不是一个整数，就提示他反复输入，知道输入一个整数为止
```java
//如果用户输入的不是一个整数，就提示他反复输入，直到输入一个整数为止
//思路
//1. 创建Scanner对象
//2. 使用无限循环，去接收一个输入
//3. 然后将该输入的值，转成一个int
//4. 如果在转换时，抛出异常，说明输入的内容不是一个可以转成int的内容
//5. 如果没有抛出异常，则break 该循环
Scanner scanner = new Scanner(System.in);
int num = 0;
String inputStr = "";
while (true) {

	System.out.println("请输入一个整数:"); //
	inputStr = scanner.next();
	try {
		num = Integer.parseInt(inputStr); //这里是可能抛出异常
		break;
	} catch (NumberFormatException e) {
		System.out.println("你输入的不是一个整数:");
	}
}

System.out.println("你输入的值是=" + num);
```

以下是Utility中读取整形的源码，大家可以对比以下
```java
/**
 * 功能：读取键盘输入的整型，长度小于2位
 * @return 整数
 */
public static int readInt() {
	int n;
	for (; ; ) {
		String str = readKeyBoard(10, false);//一个整数，长度<=10位
		try {
			n = Integer.parseInt(str);//将字符串转换成整数
			break;
		} catch (NumberFormatException e) {
			System.out.print("数字输入错误，请重新输入：");
		}
	}
	return n;
}
```


# 3 throws异常处理机制

## 3.1 基本介绍：
1）如果一个方法（中的语句执行时）可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理
2）在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类


## 3.2 案例引入，使用细节

```java
public static void main(String[] args) {
        f2();
    }
 
    public static void f2() /*throws ArithmeticException*/ {
        //1.对于编译异常，程序中必须处理，比如 try-catch 或者 throws
        //2.对于运行时异常，程序中如果没有处理，默认就是throws的方式处理
 
        int n1 = 10;
        int n2 = 0;
        double res = n1 / n2;
    }
```

```java
public static void f1() throws FileNotFoundException {
        //这里大家思考问题 调用f3() 报错
        //1. 因为f3() 方法抛出的是一个编译异常
        //2. 即这时，就要f1() 必须处理这个编译异常
        //3. 在f1() 中，要么 try-catch-finally ,或者继续throws 这个编译异常
        f3(); // 抛出异常
    }
    public static void f3() throws FileNotFoundException {
        FileInputStream fis = new FileInputStream("d://aa.txt");
    }
 
小结：即若一个方法抛出异常，则谁调用这个方法，谁就要处理这个异常
```

```java
public static void f4() {
        //1. 在f4()中调用方法f5() 是OK
        //2. 原因是f5() 抛出的是运行异常
        //3. 而java中，并不要求程序员显示处理,因为有默认处理机制
        f5();
    }
    public static void f5() throws ArithmeticException {
 
    }
```

```java
class Father { //父类
    public void method() throws RuntimeException {
    }
}
 
class Son extends Father {//子类
    //3. 子类重写父类的方法时，对抛出异常的规定:子类重写的方法，
    //   所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常类型的子类型
    //4. 在throws 过程中，如果有方法 try-catch , 就相当于处理异常，就可以不必throws
    @Override
    public void method() throws ArithmeticException {
    }
}
```

这里我们就必须要搞清楚异常之间的继承和实现关系，因此我们需要熟练掌握异常体系图


# 4 自定义异常
1.基本概念
当程序中出现某些“错误”，但该错误信息并没有在Throwable子类中描述处理，这个时候可以自己设计异常类，用于描述该错误信息

2.自定义异常的步骤
1）定义类：自定义异常类名继承Exception 或 RuntimeException
2）如果继承Exception ， 属于编译异常
3）如果继承RuntimeException，属于运行异常

3.案例引入
这里出现的throw和前面的throws是有区别的
throws 是异常处理的一种方式，通常在方法声明处出现，后面加异常类型
throw 是手动生成异常对象的关键字，通常在方法体中出现，后面加异常对象

```java
//自定义一个异常
//1. 一般情况下，我们自定义异常是继承 RuntimeException
//2. 即把自定义异常做成 运行时异常，好处时，我们可以使用默认的处理机制
//3. 即比较方便
class AgeException extends RuntimeException {
    public AgeException(String message) {
        super(message);
    }
}
 
 
int age = 180;
        //要求范围在 18 – 120 之间，否则抛出一个自定义异常
        if(!(age >= 18 && age <= 120)) {
            //这里我们可以通过构造器，设置信息
            throw new AgeException("年龄需要在 18~120之间");
        }
        System.out.println("你的年龄范围正确.");
```
